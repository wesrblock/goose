{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"Goose is your on-machine developer agent, automating engineering tasks seamlessly within your IDE or terminal  <p>   Generated by Goose from its VincentVanCode toolkit. </p> <p> </p> <p> Unique features \ud83e\udd16 \u2022  Testimonials on Goose \ud83d\udc69\u200d\ud83d\udcbb \u2022 Quickstart guide \ud83d\ude80 \u2022 Getting involved! \ud83d\udc4b </p> <p>Tip</p> <p>Quick install: <pre><code>pipx install goose-ai\n</code></pre></p> <p>Goose is a developer agent that supercharges your software development by automating an array of coding tasks directly within your terminal or IDE. Guided by you, it can intelligently assess your project's needs, generate the required code or modifications, and implement these changes on its own. Goose can interact with a multitude of tools via external APIs such as Jira, GitHub, Slack, infrastructure and data pipelines, and more -- if your task uses a shell command or can be carried out by a Python script, Goose can do it for you too! Like semi-autonomous driving, Goose handles the heavy lifting, allowing you to focus on other priorities. Simply set it on a task and return later to find it completed, boosting your productivity with less manual effort.</p>"},{"location":"index.html#unique-features-of-goose-compared-to-other-ai-assistants","title":"Unique features of Goose compared to other AI assistants","text":"<ul> <li> <p>Autonomy: A copilot should be able to also fly the plane at times, which in the development world means running code, debugging tests, installing dependencies, not just providing text output and autocomplete or search. Goose moves beyond just generating code snippets by (1) using the shell and (2) by seeing what happens with the code it writes and starting a feedback loop to solve harder problems, refining solutions iteratively like a human developer. Your code's best wingman.</p> </li> <li> <p>Extensibility: Open-source and fully customizable, Goose integrates with your workflow and allows you to extend it for even more control. Toolkits let you add new capabilities to Goose. They are anything you can implement as a Python function (e.g. API requests, deployments, search, etc). We have a growing library of toolkits to use, but more importantly you can create your own. This gives Goose the ability to run these commands and decide if and when a tool is needed to complete your request! Creating your own toolkits give you a way to bring your own private context into Goose's capabilities.  And you can use any LLM you want under the hood, as long as it supports tool use.</p> </li> </ul>"},{"location":"index.html#what-users-have-to-say-about-goose","title":"What users have to say about Goose","text":"<p>With Goose, I feel like I am Maverick.</p> <p>Thanks a ton for creating this. \ud83d\ude4f I have been having way too much fun with it today.</p> <p>-- P, Machine Learning Engineer</p> <p>I wanted to construct some fake data for an API with a large request body and business rules I haven't memorized. So I told Goose which object to update and a test to run that calls the vendor. Got it to use the errors descriptions from the vendor response to keep correcting the request until it was successful. So good!</p> <p>-- J, Software Engineer</p> <p>I asked Goose to write up a few Google Scripts that mimic Clockwise's functionality (particularly, creating blocks on my work calendar based on events in my personal calendar, as well as color-coding calendar entries based on type and importance). Took me under an hour. If you haven't tried Goose yet, I highly encourage you to do so!</p> <p>-- M, Software Engineer</p> <p>If anyone was looking for another reason to check it out: I just asked Goose to break a string-array into individual string resources across eleven localizations, and it performed amazingly well and saved me a bunch of time doing it manually or figuring out some way to semi-automate it.</p> <p>-- A, Android Engineer</p> <p>Hi team, thank you for much for making Goose, it's so amazing. Our team is working on migrating Dashboard components to React components. I am working with Goose to help the migration.</p> <p>-- K, Software Engineer</p> <p>Got Goose to update a dependency, run tests, make a branch and a commit... it was \ud83e\udd0c. Not that complicated but I was impressed it figured out how to run tests from the README.</p> <p>--  J, Software Engineer</p> <p>Wanted to document what I had Goose do -- took about 30 minutes end to end! I created a custom CLI command in the <code>gh CLI</code> library to download in-line comments on PRs about code changes (currently they aren't directly viewable). I don't know Go that well and I definitely didn't know where to start looking in the code base or how to even test the new command was working and Goose did it all for me \ud83d\ude01</p> <p>-- L, Software Engineer</p> <p>Hi Team, just wanted to share my experience of using Goose as a non-engineer! ... I just asked Goose to ensure that my environment is up to date and copied over a guide into my prompt. Goose managed everything flawlessly, keeping me informed at every step... I was truly impressed with how well it works and how easy it was to get started! \ud83d\ude0d</p> <p>-- M, Product Manager</p> <p>See more of our use-cases in our docs!</p>"},{"location":"index.html#getting-involved","title":"Getting involved!","text":"<p>There is a lot to do! If you're interested in contributing, a great place to start is picking a <code>good-first-issue</code>-labelled ticket from our issues list. More details on how to develop Goose can be found in our Contributing Guide. We are a friendly, collaborative group and look forward to working together!<sup>1</sup></p> <p>Check out and contribute to more experimental features in Goose Plugins!</p> <p>Let us know what you think in our Discussions or the <code>#goose</code> channel on Discord.</p> <ol> <li> <p>Yes, Goose is open source and always will be. Goose is released under the ASL2.0 license meaning you are free to use it however you like.  See LICENSE.md for more details.\u00a0\u21a9</p> </li> </ol>"},{"location":"configuration.html","title":"Configuring Goose","text":""},{"location":"configuration.html#profiles","title":"Profiles","text":"<p>If you need to customize goose, one way is via editing: <code>~/.config/goose/profiles.yaml</code>.</p> <p>By default, it looks like this:</p> <pre><code>default:\n  provider: open-ai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - name: developer\n      requires: {}\n</code></pre> <p>If you run <code>goose session start</code> without the <code>--profile</code> flag it will use the <code>default</code> profile automatically.</p>"},{"location":"configuration.html#fields","title":"Fields","text":""},{"location":"configuration.html#provider","title":"provider","text":"<p><code>provider</code> specifies the chosen LLM provider by the user. You can set up multiple profiles with different providers. Goose will use the provider specified in the profile to interact with the LLM. Here is the list of supported LLM providers</p>"},{"location":"configuration.html#processor","title":"processor","text":"<p>This is the model used for the main Goose loop and main tools -- it should be be capable of complex, multi-step tasks such as writing code and executing commands. Example: <code>gpt-4o</code>. You should choose the model based the provider you configured.</p>"},{"location":"configuration.html#accelerator","title":"accelerator","text":"<p>Small model for fast, lightweight tasks. Example: <code>gpt-4o-mini</code>. You should choose the model based the provider you configured.</p>"},{"location":"configuration.html#moderator","title":"moderator","text":"<p>Rules designed to control or manage the output of the model. Moderators that currently are supported by Goose:</p> <ul> <li><code>passive</code>: does not actively intervene in every response</li> <li><code>truncate</code>: truncates the first contexts when the contexts exceed the max token size</li> </ul>"},{"location":"configuration.html#toolkits","title":"toolkits","text":"<p>These are modular add-ons that enhance the functionality of Goose. Each toolkit provides specific capabilities or integrations that can be tailored to meet particular needs or use cases e.g <code>browser</code>, <code>developer</code>, <code>screen</code> etc. </p> <p>To list available toolkits, use the following command:</p> <pre><code>  goose toolkit list\n</code></pre>"},{"location":"configuration.html#adding-a-toolkit","title":"Adding a toolkit","text":"<p>To make a toolkit available to Goose, add it to your project's pyproject.toml. For example in the Goose pyproject.toml file: <pre><code>[project.entry-points.\"goose.toolkit\"]\ndeveloper = \"goose.toolkit.developer:Developer\"\ngithub = \"goose.toolkit.github:Github\"\n# Add a line like this - the key becomes the name used in profiles\nmy-new-toolkit = \"goose.toolkit.my_toolkits:MyNewToolkit\"  # this is the path to the class that implements the toolkit\n</code></pre></p> <p>Then to set up a profile that uses it, add something to <code>~/.config/goose/profiles.yaml</code>: <pre><code>my-profile:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:  # new toolkit gets added here\n    - developer\n    - my-new-toolkit\n</code></pre></p> <p>And now you can run Goose with this new profile to use the new toolkit!</p> <pre><code>goose session start --profile my-profile\n</code></pre> <p>Or, if you're developing a new toolkit and want to test it: <pre><code>uv run goose session start --profile my-profile\n</code></pre></p>"},{"location":"configuration.html#tuning-goose-to-your-repo","title":"Tuning Goose to your repo","text":"<p>Goose ships with the ability to read in the contents of a file named <code>.goosehints</code> from your repo. If you find yourself repeating the same information across sessions to Goose, this file is the right place to add this information.</p> <p>This file will be read into the Goose system prompt if it is present in the current working directory.</p> <p>Check out the guide on using .goosehints for more tips.</p> <p>Note</p> <p><code>.goosehints</code> follows jinja templating rules in case you want to leverage templating to insert file contents or variables.</p>"},{"location":"contributing.html","title":"Contributing","text":"<p>We welcome Pull Requests for general contributions. If you have a larger new feature or any questions on how to develop a fix, we recommend you open an issue before starting.</p>"},{"location":"contributing.html#prerequisites","title":"Prerequisites","text":"<p>Goose uses uv for dependency management, and formats with ruff. Clone goose and make sure you have installed <code>uv</code> to get started. When you use <code>uv</code> below in your local goose directly, it will automatically setup the virtualenv and install dependencies.</p> <p>We provide a shortcut to standard commands using just in our <code>justfile</code>.</p>"},{"location":"contributing.html#development","title":"Development","text":"<p>Now that you have a local environment, you can make edits and run our tests!</p>"},{"location":"contributing.html#run-goose","title":"Run Goose","text":"<p>If you've made edits and want to try them out, use</p> <pre><code>uv run goose session start\n</code></pre> <p>or other <code>goose</code> commands.</p> <p>If you want to run your local changes but in another directory, you can use the path in the virtualenv created by uv:</p> <pre><code>alias goosedev=`uv run which goose`\n</code></pre> <p>You can then run <code>goosedev</code> from another dir and it will use your current changes.</p>"},{"location":"contributing.html#run-tests","title":"Run Tests","text":"<p>To run the test suite against your edges, use <code>pytest</code>:</p> <pre><code>uv run pytest tests -m \"not integration\"\n</code></pre> <p>or, as a shortcut,</p> <pre><code>just test\n</code></pre>"},{"location":"contributing.html#enable-traces-in-goose-with-locally-hosted-langfuse","title":"Enable traces in Goose with locally hosted Langfuse","text":"<p>Note</p> <p>This integration is experimental and we don't currently have integration tests for it.</p> <p>Developers can use locally hosted Langfuse tracing by applying the custom <code>observe_wrapper</code> decorator defined in <code>packages/exchange/src/exchange/observers</code> to functions for automatic integration with Langfuse, and potentially other observability providers in the future. </p> <ul> <li>Add an <code>observers</code> array to your profile containing <code>langfuse</code>.</li> <li>Run <code>just langfuse-server</code> to start your local Langfuse server. It requires Docker.</li> <li>Go to http://localhost:3000 and log in with the default email/password output by the shell script (values can also be found in the <code>.env.langfuse.local</code> file).</li> <li>Run Goose with the --tracing flag enabled i.e., <code>goose session start --tracing</code></li> <li>View your traces at http://localhost:3000</li> </ul> <p><code>To extend tracing to additional functions, import</code>from exchange.observers import observe_wrapper<code>and use the</code>observe_wrapper()<code>decorator on functions you wish to enable tracing for.</code>observe_wrapper` functions the same way as Langfuse's observe decorator. </p> <p>Read more about Langfuse's decorator-based tracing here.</p>"},{"location":"contributing.html#other-observability-plugins","title":"Other observability plugins","text":"<p>In case locally hosted Langfuse doesn't fit your needs, you can alternatively use other <code>observer</code> telemetry plugins to ingest data with the same interface as the Langfuse integration. To do so, extend <code>packages/exchange/src/exchange/observers/base.py:Observer</code> and include the new plugin's path as an entrypoint in <code>exchange</code>'s <code>pyproject.toml</code>.</p>"},{"location":"contributing.html#exchange","title":"Exchange","text":"<p>The lower level generation behind goose is powered by the <code>exchange</code> package, also in this repo.</p> <p>Thanks to <code>uv</code> workspaces, any changes you make to <code>exchange</code> will be reflected in using your local goose. To run tests for exchange, head to <code>packages/exchange</code> and run tests just like above</p> <pre><code>uv run pytest tests -m \"not integration\"\n</code></pre>"},{"location":"contributing.html#evaluations","title":"Evaluations","text":"<p>Given that so much of Goose involves interactions with LLMs, our unit tests only go so far to confirming things work as intended.</p> <p>We're currently developing a suite of evaluations, to make it easier to make improvements to Goose more confidently.</p> <p>In the meantime, we typically incubate any new additions that change the behavior of the Goose through opt-in plugins - <code>Toolkit</code>s, <code>Moderator</code>s, and <code>Provider</code>s. We welcome contributions of plugins that add new capabilities to goose. We recommend sending in several examples of the new capabilities in action with your pull request.</p> <p>Additions to the developer toolkit change the core performance, and so will need to be measured carefully.</p>"},{"location":"contributing.html#conventional-commits","title":"Conventional Commits","text":"<p>This project follows the Conventional Commits specification for PR titles. Conventional Commits make it easier to understand the history of a project and facilitate automation around versioning and changelog generation.</p>"},{"location":"contributing.html#release","title":"Release","text":"<p>In order to release a new version of goose, you need to do the following: 1. Update CHANGELOG.md. To get the commit messages since last release, run: <code>just release-notes</code> 2. Update version in <code>pyproject.toml</code> for <code>goose</code> and package dependencies such as <code>exchange</code> 3. Create a PR and merge it into main branch 4. Tag the HEAD commit in main branch. To do this, switch to main branch and run: <code>just tag-push</code> 5. Publish a new release from the Github Release UI</p>"},{"location":"installation.html","title":"Installation","text":"<p>To install Goose, use <code>pipx</code> on macOS, Linux, or Windows. </p> <p>First, ensure pipx is installed:</p> <pre><code>brew install pipx\npipx ensurepath\n</code></pre> <p>Then install Goose:</p> <pre><code>pipx install goose-ai\n</code></pre>"},{"location":"installation.html#configuration","title":"Configuration","text":""},{"location":"installation.html#set-up-a-provider","title":"Set up a provider","text":"<p>Goose works with a set of supported LLM providers that you can obtain an API key from if you don't already have one. You'll be prompted to set an API key if you haven't set one previously when you run Goose.</p> <p>Tip</p> <p>Billing:</p> <p>You will need to have credits in your LLM Provider account (when necessary) to be able to successfully make requests.</p>"},{"location":"installation.html#profiles","title":"Profiles","text":"<p>After installation, you can configure Goose anytime by editing your profile file located at <code>~/.config/goose/profiles.yaml</code>. You can set multiple profile configurations, use different LLM providers, and enable toolkits that customize Goose's functionality as well:</p> <pre><code>default:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - name: developer\n      requires: {}\n</code></pre>"},{"location":"installation.html#running-goose","title":"Running Goose","text":"<p>You can run <code>goose</code> from the command line using:</p> <pre><code>goose session start\n</code></pre>"},{"location":"installation.html#additional-resources","title":"Additional Resources","text":"<p>Visit the Configuration Guide for detailed instructions on configuring Goose.</p>"},{"location":"quickstart.html","title":"Goose in 5 minutes","text":""},{"location":"quickstart.html#quickstart-guide","title":"Quickstart guide","text":"<p>Goose is a developer agent that supercharges your software development by automating an array of coding tasks directly within your terminal or IDE. You can get it setup and running on your devices in only a few minutes.</p>"},{"location":"quickstart.html#installation","title":"Installation","text":"<p>To install Goose, use <code>pipx</code>. First ensure pipx is installed:</p> <pre><code>brew install pipx\npipx ensurepath\n</code></pre> <p>Then install Goose:</p> <pre><code>pipx install goose-ai\n</code></pre>"},{"location":"quickstart.html#running-goose","title":"Running Goose","text":""},{"location":"quickstart.html#set-up-a-provider","title":"Set up a provider","text":"<p>Goose works with a set of supported LLM providers that you can obtain an API key from if you don't already have one. You'll be prompted to set an API key if you haven't set one previously when you run Goose.</p> <p>Tip</p> <p>Billing:</p> <p>You will need to have credits in your LLM Provider account (when necessary) to be able to successfully make requests.</p>"},{"location":"quickstart.html#start-a-session","title":"Start a session","text":"<p>From your terminal, navigate to the directory you'd like to start from and run:</p> <pre><code>goose session start\n</code></pre>"},{"location":"quickstart.html#make-goose-do-the-work-for-you","title":"Make Goose do the work for you","text":"<p>You will see the Goose prompt <code>G\u276f</code>:</p> <pre><code>G\u276f type your instructions here exactly as you would speak to a developer.\n</code></pre> <p>e.g</p> <pre><code>G\u276f Create a JavaScript project that fetches and displays weather for a user specified city using a public API\n</code></pre> <p>Now you are interacting with Goose in conversational sessions. Think of it like you're giving directions to a junior developer. The default toolkit allows Goose to take actions through shell commands and file edits. You can interrupt Goose with <code>CTRL+D</code> or <code>ESC+Enter</code> at any time to help redirect its efforts.</p>"},{"location":"quickstart.html#exit-the-session","title":"Exit the session","text":"<p>If you are looking to exit, use <code>CTRL+D</code>.</p>"},{"location":"quickstart.html#resume-a-session","title":"Resume a session","text":"<p>When you exit a session, it will save the history in <code>~/.config/goose/sessions</code> directory. You can then resume your last saved session later, using:</p> <pre><code>goose session resume\n</code></pre> <p>Check out the Managing Goose sessions to learn more about working with sessions in Goose.</p> <p>To see more documentation on the available CLI commands, check out the documentation. If you\u2019d like to develop your own CLI commands for Goose, check out the Contributing document.</p>"},{"location":"quickstart.html#running-a-goose-task","title":"Running a Goose task","text":"<p>You can run Goose to do things just as a one off, such as tidying up, and then exiting:</p> <pre><code>goose run instructions.md\n</code></pre> <p>You can also use process substitution to provide instructions directly from the command line:</p> <pre><code>goose run &lt;(echo \"Create a new Python file that prints hello world\")\n</code></pre> <p>This will run until completion as best it can. You can also pass <code>--resume-session</code> and it will re-use the first session it finds for context.</p>"},{"location":"quickstart.html#additional-tips","title":"Additional tips","text":"<p>You can place a <code>.goosehints</code> file in <code>~/.config/goose/.goosehints</code> for hints personal to you. Goose will automatically load these within your sessions.</p>"},{"location":"quickstart.html#next-steps","title":"Next steps","text":"<p>Review the Getting Started Guide to learn how to modify the Goose <code>profiles.yaml</code> file to add and remove functionality (toolkits) and provide additional context to get the most out of Goose.</p> <p>Want to move out of the terminal and into an IDE?</p> <p>We have some experimental IDE integrations for VSCode and JetBrains IDEs: * https://github.com/square/goose-vscode * https://github.com/Kvadratni/goose-intellij</p> <p>Goose as a Github Action</p> <p>There is also an experimental Github action to run Goose as part of your workflow (e.g., if you ask it to fix an issue): https://github.com/marketplace/actions/goose-ai-developer-agent</p> <p>With Docker</p> <p>There is also a <code>Dockerfile</code> in the root of this project you can use if you want to run goose in a sandboxed fashion.</p>"},{"location":"blog/index.html","title":"Blog","text":""},{"location":"blog/2024/11/22/screenshot-driven-development.html","title":"Screenshot-Driven Development","text":"<p>I'm a developer at heart, so when I'm working on a personal project, the hardest part isn't writing code\u2014it's making design decisions. I recently built a calendar user interface. I wanted to enhance its visual appeal, so I researched UI design trends like \"glassmorphism\" and \"claymorphism.\"</p> <p>However, I didn't want to spend hours implementing the CSS for each design trend, so I developed a faster approach: screenshot-driven development. I used an open source developer agent called Goose to transform my user interfaces quickly.</p>"},{"location":"blog/2024/11/22/screenshot-driven-development.html#my-original-calendar","title":"My original calendar:","text":""},{"location":"blog/2024/11/22/screenshot-driven-development.html#goose-prototyped-the-designs-below","title":"Goose prototyped the designs below:","text":"<p>In this blog post, I'll show you how to quickly prototype design styles by letting Goose handle the CSS for you.</p> <p>\ud83d\udca1 Note: Your results might look different from my examples - that's part of the fun of generative AI! Each run can produce unique variations of these design trends.</p>"},{"location":"blog/2024/11/22/screenshot-driven-development.html#get-started-with-screenshot-driven-development","title":"Get Started with Screenshot-Driven Development","text":""},{"location":"blog/2024/11/22/screenshot-driven-development.html#step-1-create-your-ui","title":"Step 1: Create your UI","text":"<p>Let's create a basic UI to experiment with. Create an index.html file with the code below:</p> Create an index.html file with the code below <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;style&gt;\n        body {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            min-height: 100vh;\n            margin: 0;\n            background: linear-gradient(45deg, #6e48aa, #9c27b0);\n            font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n        }\n\n        .calendar {\n            background: white;\n            border-radius: 12px;\n            box-shadow: 0 5px 20px rgba(0,0,0,0.1);\n            width: 400px;\n            padding: 20px;\n        }\n\n        .header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            padding-bottom: 20px;\n            border-bottom: 2px solid #f0f0f0;\n        }\n\n        .month {\n            font-size: 24px;\n            font-weight: 600;\n            color: #1a1a1a;\n        }\n\n        .days {\n            display: grid;\n            grid-template-columns: repeat(7, 1fr);\n            gap: 10px;\n            margin-top: 20px;\n            text-align: center;\n        }\n\n        .days-header {\n            display: grid;\n            grid-template-columns: repeat(7, 1fr);\n            gap: 10px;\n            margin-top: 20px;\n            text-align: center;\n        }\n\n        .days-header span {\n            color: #666;\n            font-weight: 500;\n            font-size: 14px;\n        }\n\n        .day {\n            aspect-ratio: 1;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            border-radius: 50%;\n            font-size: 14px;\n            color: #333;\n            cursor: pointer;\n            transition: all 0.2s;\n        }\n\n        .day:hover {\n            background: #f0f0f0;\n        }\n\n        .day.today {\n            background: #9c27b0;\n            color: white;\n        }\n\n        .day.inactive {\n            color: #ccc;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"calendar\"&gt;\n        &lt;div class=\"header\"&gt;\n            &lt;div class=\"month\"&gt;November 2024&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=\"days-header\"&gt;\n            &lt;span&gt;Sun&lt;/span&gt;\n            &lt;span&gt;Mon&lt;/span&gt;\n            &lt;span&gt;Tue&lt;/span&gt;\n            &lt;span&gt;Wed&lt;/span&gt;\n            &lt;span&gt;Thu&lt;/span&gt;\n            &lt;span&gt;Fri&lt;/span&gt;\n            &lt;span&gt;Sat&lt;/span&gt;\n        &lt;/div&gt;\n        &lt;div class=\"days\"&gt;\n            &lt;div class=\"day inactive\"&gt;27&lt;/div&gt;\n            &lt;div class=\"day inactive\"&gt;28&lt;/div&gt;\n            &lt;div class=\"day inactive\"&gt;29&lt;/div&gt;\n            &lt;div class=\"day inactive\"&gt;30&lt;/div&gt;\n            &lt;div class=\"day inactive\"&gt;31&lt;/div&gt;\n            &lt;div class=\"day\"&gt;1&lt;/div&gt;\n            &lt;div class=\"day\"&gt;2&lt;/div&gt;\n            &lt;div class=\"day\"&gt;3&lt;/div&gt;\n            &lt;div class=\"day\"&gt;4&lt;/div&gt;\n            &lt;div class=\"day\"&gt;5&lt;/div&gt;\n            &lt;div class=\"day\"&gt;6&lt;/div&gt;\n            &lt;div class=\"day\"&gt;7&lt;/div&gt;\n            &lt;div class=\"day\"&gt;8&lt;/div&gt;\n            &lt;div class=\"day\"&gt;9&lt;/div&gt;\n            &lt;div class=\"day\"&gt;10&lt;/div&gt;\n            &lt;div class=\"day\"&gt;11&lt;/div&gt;\n            &lt;div class=\"day\"&gt;12&lt;/div&gt;\n            &lt;div class=\"day\"&gt;13&lt;/div&gt;\n            &lt;div class=\"day today\"&gt;14&lt;/div&gt;\n            &lt;div class=\"day\"&gt;15&lt;/div&gt;\n            &lt;div class=\"day\"&gt;16&lt;/div&gt;\n            &lt;div class=\"day\"&gt;17&lt;/div&gt;\n            &lt;div class=\"day\"&gt;18&lt;/div&gt;\n            &lt;div class=\"day\"&gt;19&lt;/div&gt;\n            &lt;div class=\"day\"&gt;20&lt;/div&gt;\n            &lt;div class=\"day\"&gt;21&lt;/div&gt;\n            &lt;div class=\"day\"&gt;22&lt;/div&gt;\n            &lt;div class=\"day\"&gt;23&lt;/div&gt;\n            &lt;div class=\"day\"&gt;24&lt;/div&gt;\n            &lt;div class=\"day\"&gt;25&lt;/div&gt;\n            &lt;div class=\"day\"&gt;26&lt;/div&gt;\n            &lt;div class=\"day\"&gt;27&lt;/div&gt;\n            &lt;div class=\"day\"&gt;28&lt;/div&gt;\n            &lt;div class=\"day\"&gt;29&lt;/div&gt;\n            &lt;div class=\"day\"&gt;30&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Once saved, open the file in your browser. You should see a calendar!</p>"},{"location":"blog/2024/11/22/screenshot-driven-development.html#step-2-install-goose","title":"Step 2: Install Goose","text":"<pre><code>brew install pipx\npipx ensurepath\npipx install goose-ai\n</code></pre>"},{"location":"blog/2024/11/22/screenshot-driven-development.html#step-3-start-a-session","title":"Step 3: Start a session","text":"<pre><code>goose session start\n</code></pre>"},{"location":"blog/2024/11/22/screenshot-driven-development.html#bring-your-own-llm","title":"Bring your own LLM","text":"<p>Goose will prompt you to set up your API key when you first run this command. You can use various LLM providers like OpenAI or Anthropic</p> <pre><code>export OPENAI_API_KEY=your_api_key\n# Or for other providers:\nexport ANTHROPIC_API_KEY=your_api_key\n</code></pre>"},{"location":"blog/2024/11/22/screenshot-driven-development.html#step-4-enable-the-screen-toolkit","title":"Step 4: Enable the Screen toolkit","text":"<p>Goose uses toolkits to extend its capabilities. The screen toolkit lets Goose take and analyze screenshots.</p> <p>To enable the Screen toolkit, add it to your Goose profile at ~/.config/goose/profiles.yaml.</p> <p>Your configuration might look slightly different depending on your LLM provider preferences.</p> <pre><code>default:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: truncate\n  toolkits:\n  - name: developer\n    requires: {}\n  - name: screen\n    requires: {}\n</code></pre>"},{"location":"blog/2024/11/22/screenshot-driven-development.html#step-5-prompt-goose-to-screenshot-your-ui","title":"Step 5: Prompt Goose to screenshot your UI","text":"<p>Goose analyzes your UI through screenshots to understand its structure and elements. In your Gooses session, prompt Goose to take a screenshot by specifying which display your UI is on:</p> <pre><code>Take a screenshot of display(1)  \n</code></pre> <p>The display number is required - use display(1) for your main monitor or display(2) for a secondary monitor.</p> <p>Upon success, Goose will run a <code>screencapture</code> command and save it as a temporary file.</p>"},{"location":"blog/2024/11/22/screenshot-driven-development.html#step-6-prompt-goose-to-transform-your-ui","title":"Step 6: Prompt Goose to transform your UI","text":"<p>Now, you can ask Goose to apply different design styles. Here are some of the prompts I gave Goose and the results it produced:</p>"},{"location":"blog/2024/11/22/screenshot-driven-development.html#glassmorphism","title":"Glassmorphism","text":"<pre><code>Apply a glassmorphic effect to my UI\n</code></pre>"},{"location":"blog/2024/11/22/screenshot-driven-development.html#neumorphism","title":"Neumorphism","text":"<pre><code>Apply neumorphic effects to my calendar and the dates\n</code></pre>"},{"location":"blog/2024/11/22/screenshot-driven-development.html#claymorphism","title":"Claymorphism","text":"<pre><code>Please replace with a claymorphic effect\n</code></pre>"},{"location":"blog/2024/11/22/screenshot-driven-development.html#brutalism","title":"Brutalism","text":"<pre><code>Apply a brutalist effect please\n</code></pre>"},{"location":"blog/2024/11/22/screenshot-driven-development.html#learn-more","title":"Learn More","text":"<p>Developing user interfaces is a blend of creativity and problem-solving. And I love that using Goose gives me more time to focus on creativity rather than wrestling with CSS for hours. </p> <p>Beyond prototyping, Goose's ability to analyze screenshots can help developers identify and resolve UI bugs.</p> <p>If you're interested in learning more, check out the Goose repo and join our Discord community.</p>"},{"location":"guidance/applications.html","title":"Applications of Goose","text":""},{"location":"guidance/applications.html#uses-of-goose-so-far","title":"Uses of Goose so Far","text":"<p>We've been using Goose to help us with a variety of tasks. Here are some examples:</p> <ul> <li>Conduct code migrations like:<ul> <li>Ember to React</li> <li>Ruby to Kotlin</li> <li>Prefect-1 to Prefect-2</li> </ul> </li> <li>Dive into a new project in an unfamiliar coding language</li> <li>Transition a code-base from field-based injection to constructor-based injection in a dependency injection framework</li> <li>Conduct performance benchmarks for a build command using a build automation tool</li> <li>Increasing code coverage above a specific threshold</li> <li>Scaffolding an API for data retention</li> <li>Creating Datadog monitors</li> <li>Removing or adding feature flags</li> </ul>"},{"location":"guidance/getting-started.html","title":"Your first run with Goose","text":"<p>This page contains two sections that will help you get started with Goose:</p> <ol> <li>Configuring Goose with the <code>profiles.yaml</code> file: how to set up Goose with the right LLMs and toolkits.</li> <li>Working with Goose: how to guide Goose through a task, and how to provide context for Goose to work with.</li> </ol>"},{"location":"guidance/getting-started.html#configuring-goose-with-the-profilesyaml-file","title":"Configuring Goose with the <code>profiles.yaml</code> file","text":"<p>On the first run, Goose will detect what LLMs are available from your environment, and generate a configuration file at <code>~/.config/goose/profiles.yaml</code>. You can edit those profiles to further configure goose.</p> <p>Here\u2019s what the default <code>profiles.yaml</code> could look like if Goose detects an OpenAI API key:</p> <pre><code>default:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: truncate\n  toolkits:\n    - name: developer\n      requires: {}\n</code></pre> <p>You can edit this configuration file to use different LLMs and toolkits in Goose. Check out the configuration docs to better understand the different fields of the <code>profiles.yaml</code> file! You can add new profiles with different settings to change how goose works from one section to the next - use <code>goose session start --profile {profile}</code> to select which to use.</p>"},{"location":"guidance/getting-started.html#llm-provider-access-setup","title":"LLM provider access setup","text":"<p>Goose works on top of LLMs.  You'll need to configure one before using it. By default, Goose uses <code>openai</code> as the LLM provider but you can customize it as needed. You need to set OPENAI_API_KEY as an environment variable if you would like to use <code>openai</code>.</p> <p>To learn more about providers and modes of access, check out the provider docs. <pre><code>export OPENAI_API_KEY=your_open_api_key\n</code></pre></p>"},{"location":"guidance/getting-started.html#working-with-goose","title":"Working with Goose","text":"<p>Goose works best with some amount of context or instructions for a given task. You can guide goose through gathering the context it needs by giving it instructions or asking it to explore with its tools. But to make this easier, context in Goose can be extended a few additional ways:</p> <ol> <li>User-directed input</li> <li>A <code>.goosehints</code> file</li> <li>Toolkits</li> <li>Plans</li> </ol>"},{"location":"guidance/getting-started.html#user-directed-input","title":"User-directed input","text":"<p>Directing Goose to read a specific file before requesting changes ensures that the file's contents are loaded into its operational context. Similarly, asking Goose to summarize the current project before initiating changes across multiple files provides a detailed overview of the project structure, including the locations of specific classes, functions, and other components.</p>"},{"location":"guidance/getting-started.html#goosehints","title":"<code>.goosehints</code>","text":"<p>If you are using the <code>developer</code> toolkit, <code>goose</code> adds the content from <code>.goosehints</code> file in the working directory to the system prompt. The hints file is meant to provide additional context about your project. The context can be user-specific or at the project level in which case, you can commit it to git. <code>.goosehints</code> file is Jinja templated so you could have something like this:</p> <pre><code>Here is an overview of how to contribute:\n&amp;#123;% include 'CONTRIBUTING.md' %&amp;#125;\n\nThe following justfile shows our common commands:\n&amp;#123;% include 'justfile' %&amp;#125;\n\nWrite all code comments in French\n</code></pre> <p>Check out the guide on using .goosehints for more tips.</p>"},{"location":"guidance/getting-started.html#toolkits","title":"Toolkits","text":"<p>Toolkits expand Goose\u2019s capabilities and tailor its functionality to specific development tasks. Toolkits provide Goose with additional contextual information and interactive abilities, allowing for a more comprehensive and efficient workflow.</p> <p>Here are some out-of-the-box examples:</p> <ul> <li><code>developer</code>: for general-purpose development capabilities, including plan management, shell execution, and file operations, with default shell strategies like using ripgrep.</li> <li><code>screen</code>: for letting goose take a look at your screen to help debug or work on designs (gives goose eyes)</li> <li><code>github</code>: for suggestions on how to use Github</li> <li><code>repo_context</code>: for summarizing and understanding a repository you are working in.</li> <li><code>jira</code>: for working with JIRA (issues, backlogs, tasks, bugs etc.)</li> </ul> <p>You can see the current toolkits available to Goose here. There's also a public plugins repository where toolkits are defined for Goose that has toolkits you can try out.</p>"},{"location":"guidance/getting-started.html#plans","title":"Plans","text":"<p>Goose creates plans for itself to execute to achieve its goals. In some cases, you may already have a plan in mind for Goose \u2014 this is where you can define your own <code>plan.md</code> file, and it will set the first message and also hard code Goose's initial plan.</p> <p>The plan.md file can be text in any format and uses <code>jinja</code> templating, and the last group of lines that start with \u201c-\u201d will be considered the plan.</p> <p>Here are some examples:</p>"},{"location":"guidance/getting-started.html#basic-example-plan","title":"Basic example plan","text":"<pre><code>Your goal is to refactor this fastapi application to use a sqlite database. Use `pytest -s -v -x` to run the tests when needed.\n\n- Use ripgrep to find the fastapi app and its tests in this directory\n- read the files you found\n- Add sqlalchemy and alembic as dependencies with poetry\n- Run alembic init to set up the basic configuration\n- Add sqlite dependency with Poetry\n- Create new module for database code and include sqlalchemy and alembic setup\n- Define an accounts table with SQLAlchemy\n- Implement CRUD operations for accounts table\n- Update main.py to integrate with SQLite database and use CRUD operation\n- Use alembic to create the table\n- Use conftest to set up a test database with a new DB URL\n- Run existing test suite and ensure all tests pass. Do not edit the test case behavior, instead use tests to find issues.\n</code></pre> <p>The starting plan is specified with the tasks. Each list entry is a different step in the plan. This is a pretty detailed set of tasks, but is really just a break-down of the conversation we had in the previous section.</p> <p>The kickoff message is what gets set as the first user message when goose starts running (with the plan). This message should contain the overall goal of the tasks and could also contain extra context you want to include for this problem. In our case, we are just mentioning the test command we want to use to run the tests.</p> <p>To run Goose with this plan:</p> <pre><code>goose session start --plan plan.md\n</code></pre>"},{"location":"guidance/getting-started.html#injecting-arguments-into-a-plan","title":"Injecting arguments into a plan","text":"<p>You can also inject arguments into your plan. <code>plan.md</code> files can be templated with <code>jinja</code> and can include variables that are passed in when you start the session.</p> <p>The kickoff message gives Goose directions to use poetry and a dependency, and then a plan is to open a file, run a test, and set up a repo:</p> <pre><code>Here is the python repo\n\n- use {{ dep }}\n- use poetry\n\nHere is the plan:\n\n- Open a file\n- Run a test\n- Set up {{ repo }}\n</code></pre> <p>To run Goose with this plan with the arguments <code>dep=pytest,repo=github</code>, you would run the following command:</p> <pre><code>goose session start --plan plan.md --args dep=pytest,repo=github\n</code></pre>"},{"location":"guidance/goose-in-action.html","title":"Goose in action","text":"<p>This page is frequently updated with the latest use-cases and applications of Goose!</p>"},{"location":"guidance/goose-in-action.html#goose-as-a-github-action","title":"Goose as a Github Action","text":"<p>What it does: </p> <p>An early version of a GitHub action that uses Goose to automatically address issues in your repository. It operates in the background to attempt fixes or enhancements based on issue descriptions.</p> <p>The action attempts to fix issues described in GitHub. It takes the issue's title and body as input and tries to resolve the issue programmatically.</p> <p>If the action successfully fixes the issue, it will automatically create a pull request with the fix. If it cannot confidently fix the issue, no pull request is created.</p> <p>Where you can find it: https://github.com/marketplace/actions/goose-ai-developer-agent</p> <p>How you can do something similar:</p> <ol> <li>Decide what specific task you want Goose to automate. This could be anything from auto-linting code, updating dependencies, auto-merging approved pull requests, or even automating responses to issue comments.</li> <li>In the <code>action.yml</code>, specify any inputs your action needs (like GitHub tokens, configuration files, specific command inputs) and outputs it may produce.</li> <li>Write the script (e.g., Python or JavaScript) that Goose will use to perform the tasks. This involves setting up the Goose environment, handling GitHub API requests, and processing the task-specific logic.</li> </ol>"},{"location":"guidance/managing-goose-sessions.html","title":"Managing Goose Sessions","text":"<p>Goose sessions are your way to interact with Goose, providing a space to ask questions and prompt action. In this guide, we'll cover how to start, end, save, resume, and delete a session. </p>"},{"location":"guidance/managing-goose-sessions.html#starting-a-session","title":"Starting a Session","text":"<p>To start a new session, run the following command within your terminal: </p> <pre><code>goose session start \n</code></pre> <p>By default, Goose will provide a random string as the name of your session. If you'd like to provide a specific name, this is where you'd do so. For example to name your session 'react-migration', you would run:</p> <p><pre><code>goose session start react-migration\n</code></pre> You'll know your session has started when your terminal looks similar to the following:</p> <pre><code>starting session | name: react-migration profile: default\n</code></pre> <p>Info</p> <p>If this is your first session, Goose will prompt you for an API key to access an LLM (Large Language Model) of your choice. For more information on setting up your API key, see the Getting Started Guide. Here is the list of Goose-supported LLMs.</p>"},{"location":"guidance/managing-goose-sessions.html#exiting-a-session","title":"Exiting a Session","text":"<p>To exit a session, hold down <code>Ctrl</code> + <code>C</code> to cancel and automatically save it. Alternatively, you can type <code>exit</code> to save and exit the session.</p> <p>Your session will be stored locally in a path similar to:</p> <pre><code>~/.config/goose/logs\n</code></pre> <p>This path is typically found in your <code>Users</code> folder.</p>"},{"location":"guidance/managing-goose-sessions.html#resuming-a-session","title":"Resuming a Session","text":"<p>To resume your latest session, you can run the following command:</p> <pre><code>goose session resume\n</code></pre> <p>To resume a specific session, you can first check the sessions you currently have by running: </p> <pre><code>goose session list \n</code></pre> <p>This command will display a list of all saved sessions, showing a name, date, and time for each session. The output should look similar to the following: </p> <pre><code>2024-11-12  14:12:28  managing-goose\n2024-11-12. 13:48:11  blog\n2024-11-12  13:27:21  react-migration\n2024-11-04  16:14:29  e6d7\n</code></pre> <p>To resume a specific session, run the following command: </p> <pre><code>goose session resume react-migration\n</code></pre>"},{"location":"guidance/managing-goose-sessions.html#deleting-old-sessions","title":"Deleting Old Sessions","text":"<p>Goose allows you to delete all previously saved sessions. However, it currently doesn't allow you to select specific sessions to delete. Be cautious when running this command as all sessions prior to the day the command was ran will be deleted. </p> <p>To delete previously saved sessions, you can run the following command:</p> <p><pre><code>goose session clear\n</code></pre> You can also decide how many sessions you want to keep, starting from the most recent. To keep 2 sessions you would run the following command: </p> <pre><code>goose session clear --keep 2  \n</code></pre> <p>Info</p> <p>Once a session is deleted it can not be retrieved.</p>"},{"location":"guidance/tips.html","title":"Quick Tips","text":""},{"location":"guidance/tips.html#tips-for-working-with-goose","title":"Tips for working with Goose:","text":"<p>Here are some collected tips we have for working efficiently with Goose</p> <ul> <li>Goose can and will edit files. Use a git strategy to avoid losing anything - such as staging your personal edits and leaving Goose edits unstaged until reviewed. Or consider using individual commits which can be reverted.</li> <li>Goose can and will run commands. You can ask it to check with you first if you are concerned. It will check commands for safety as well.</li> <li>You can interrupt Goose with <code>CTRL+C</code> to correct it or give it more info.</li> <li>Goose works best when solving concrete problems - experiment with how far you need to break that problem down to get Goose to solve it. Be specific! E.g. it will likely fail to <code>\"create a banking app\"</code>, but probably does a good job if prompted with <code>\"create a Fastapi app with an endpoint for deposit and withdrawal and with account balances stored in mysql keyed by id\"</code></li> <li>If Goose doesn't have enough context to start with, it might go down the wrong direction. Tell it to read files that you are referring to or search for objects in code. Even better, ask it to summarize them for you, which will help it set up its own next steps.</li> <li>Refer to any objects in files with something that is easy to search for, such as `\"the MyExample class\"</li> <li>Goose loves to know how to run tests to get a feedback loop going, just like you do. If you tell it how you test things locally and quickly, it can make use of that when working on your project</li> <li>You can use Goose for tasks that would require scripting at times, even looking at your screen and correcting designs/helping you fix bugs, try asking it to help you in a way you would ask a person.</li> <li>Goose will make mistakes, and go in the wrong direction from times, feel free to correct it, or start again.</li> <li>You can tell Goose to run things for you continuously (and it will iterate, try, retry) but you can also tell it to check with you before doing things (and then later on tell it to go off on its own and do its best to solve).</li> <li>Goose can run anywhere, doesn't have to be in a repo, just ask it!</li> </ul>"},{"location":"guidance/using-goosehints.html","title":"Using <code>.goosehints</code> in Goose","text":"<p><code>.goosehints</code> are text files used within the Goose environment to provide additional context about your project and improve the communication between the developer and Goose. The use of <code>goosehints</code> ensures that Goose understands your requirements better and can execute tasks more effectively.</p> <p>Tip</p> <p>Developer toolkit required</p> <p>To make use of the hints file, you need to have the <code>developer</code> toolkit enabled.</p> <p>This guide will walk you through creating and using your <code>.goosehints</code> file to streamline your workflow with custom instructions and context.</p>"},{"location":"guidance/using-goosehints.html#creating-your-goosehints-file","title":"Creating your <code>.goosehints</code> file","text":"<p>You can place a <code>.goosehints</code> file in your current working directory or globally at <code>~/.config/goose/.goosehints</code>. This file can include any repeated instructions or contextual details relevant to your projects.</p> <p>A good time to consider adding a <code>.goosehints</code> file is when you find yourself repeating prompts, or providing the same kind of instructions multiple times.</p>"},{"location":"guidance/using-goosehints.html#setting-up-hints","title":"Setting up hints","text":"<p>The <code>.goosehints</code> file supports natural language and also follows jinja templating rules, so you can leverage templating to insert file contents or variables.</p> <p>Here are some ways people have used hints to provide additional context for Goose to follow:</p> <ul> <li> <p>Decision-Making: Specify if Goose should autonomously make changes or confirm actions with you first.</p> </li> <li> <p>Validation Routines: Provide test cases or validation methods that Goose should perform to ensure changes meet project specifications.</p> </li> <li> <p>Feedback Loop: Include steps that allow Goose to receive feedback and iteratively improve its suggestions.</p> </li> <li> <p>Point to more detailed documentation: Indicate important files like <code>README.md</code>, <code>CONTRIBUTING.md</code>, or others that Goose should consult for detailed explanations.</p> </li> </ul> <p>Like prompts, this is not an extensive list to shape your <code>.goosehints</code> file. You can include as much context as you need.</p> <p>Example <code>.goosehints file</code>:</p> <pre><code>This is a simple example JavaScript web application that uses the Express.js framework. View [Express documentation](https://expressjs.com/) for extended guidance.\n\nGo through the README.md for information on how to build and test it as needed.\n\nMake sure to confirm all changes with me before applying.\n\nUse the following custom values when needed:\n&amp;#123;% include custom-config.js %&amp;#125;\n\nRun tests with `npm run test` ideally after each change.\n</code></pre>"},{"location":"guidance/using-goosehints.html#best-practices","title":"Best Practices","text":"<ul> <li>Keep It Updated: Regularly update the <code>.goosehints</code> file to reflect any changes in project protocols or priorities.</li> <li>Be Concise: Make sure the content is straightforward and to the point, ensuring Goose can quickly parse and act on the information.</li> </ul>"},{"location":"plugins/available-toolkits.html","title":"Available Toolkits in Goose","text":"<p>Goose provides a variety of toolkits designed to help developers with different tasks. Here's an overview of each available toolkit and its functionalities:</p>"},{"location":"plugins/available-toolkits.html#1-developer-toolkit","title":"1. Developer Toolkit","text":"<p>The Developer toolkit offers general-purpose development capabilities, including:</p> <ul> <li>System Configuration Details: Retrieves system configuration details.</li> <li>Task Management: Update the plan by overwriting all current tasks.</li> <li>File Operations:</li> <li><code>patch_file</code>: Patch a file by replacing specific content.</li> <li><code>read_file</code>: Read the content of a specified file.</li> <li><code>write_file</code>: Write content to a specified file.</li> <li>Shell Command Execution: Execute shell commands with safety checks.</li> </ul>"},{"location":"plugins/available-toolkits.html#2-github-toolkit","title":"2. GitHub Toolkit","text":"<p>The GitHub toolkit provides detailed configuration and procedural guidelines for GitHub operations, including:</p> <ul> <li>Pull Request Reviews: View and analyze PR reviews and nested comments.</li> <li>API Integration: Access GitHub API for repository operations.</li> <li>Command Line Interface: Integration with <code>gh</code> CLI tool.</li> </ul>"},{"location":"plugins/available-toolkits.html#3-jira-toolkit","title":"3. JIRA Toolkit","text":"<p>The JIRA toolkit facilitates interaction with JIRA issues and projects through:</p> <ul> <li>Issue Management: View and interact with JIRA issues.</li> <li>Command Line Integration: Integration with <code>jira</code> CLI tool.</li> <li>Authentication: Handle JIRA authentication and initialization.</li> </ul>"},{"location":"plugins/available-toolkits.html#4-memory-toolkit","title":"4. Memory Toolkit","text":"<p>The Memory toolkit provides persistent storage capabilities:</p> <ul> <li>Local and Global Storage: Store memories in both local (.goose/memory) and global (~/.config/goose/memory) locations.</li> <li>Categorization: Organize memories with categories and tags.</li> <li>Natural Language Format: Store and retrieve memories in natural language format.</li> <li>Template Integration: Use memories in system prompts via Jinja templates.</li> </ul>"},{"location":"plugins/available-toolkits.html#5-repocontext-toolkit","title":"5. RepoContext Toolkit","text":"<p>The RepoContext toolkit provides context about the current repository:</p> <ul> <li>Repository Size: Get the size of the repository.</li> <li>Monorepo Check: Determine if the repository is a monorepo.</li> <li>Project Summarization: Summarize the current project based on the repository or project directory.</li> </ul>"},{"location":"plugins/available-toolkits.html#6-screen-toolkit","title":"6. Screen Toolkit","text":"<p>The Screen toolkit assists users in taking screenshots for debugging or designing purposes:</p> <ul> <li>Take Screenshot: Capture a screenshot and provide the path to the screenshot file.</li> <li>System Instructions: Instructions on how to work with screenshots.</li> </ul>"},{"location":"plugins/available-toolkits.html#7-summarization-toolkits","title":"7. Summarization Toolkits","text":"<p>Goose includes several summarization-focused toolkits:</p>"},{"location":"plugins/available-toolkits.html#71-summarizerepo-toolkit","title":"7.1 SummarizeRepo Toolkit","text":"<ul> <li>Repository Analysis: Clone and summarize repositories based on specified extensions.</li> </ul>"},{"location":"plugins/available-toolkits.html#72-summarizeproject-toolkit","title":"7.2 SummarizeProject Toolkit","text":"<ul> <li>Project Overview: Generate or retrieve summaries of project directories based on specified file extensions.</li> </ul>"},{"location":"plugins/available-toolkits.html#73-summarizefile-toolkit","title":"7.3 SummarizeFile Toolkit","text":"<ul> <li>File Content Analysis: Summarize specific files with optional custom instructions.</li> </ul>"},{"location":"plugins/available-toolkits.html#8-web-browser-toolkit","title":"8. Web Browser Toolkit","text":"<p>The Web Browser toolkit provides web interaction capabilities:</p> <ul> <li>Web Content Access: Fetch and analyze web content.</li> <li>URL Handling: Process and validate URLs.</li> <li>Content Extraction: Extract relevant information from web pages.</li> </ul>"},{"location":"plugins/available-toolkits.html#9-reasoner-toolkit","title":"9. Reasoner Toolkit","text":"<p>The Reasoner toolkit enhances decision-making capabilities:</p> <ul> <li>Logical Analysis: Apply reasoning to complex problems.</li> <li>Decision Support: Help evaluate options and make informed choices.</li> <li>Pattern Recognition: Identify patterns and relationships in data.</li> </ul>"},{"location":"plugins/available-toolkits.html#10-synopsis-toolkit","title":"10. Synopsis Toolkit","text":"<p>The Synopsis toolkit provides core development and system interaction capabilities. Note that this toolkit requires the Synopsis moderator to be enabled to function properly.</p> <ul> <li>Bash Operations: Execute shell commands with working directory and source file support.</li> <li>Text Editing: View, create, replace, and insert content in files with undo support.</li> <li>Process Management: Start, list, view output, and cancel background processes.</li> <li>Web Content: Fetch and analyze web content with HTML and text extraction.</li> </ul> <p>Important: This toolkit only works when used with the Synopsis moderator. Make sure the Synopsis moderator is enabled in your configuration to use these capabilities.</p>"},{"location":"plugins/cli.html","title":"Goose CLI Commands","text":"<p>Goose provides a command-line interface (CLI) with various commands to manage sessions, toolkits, and more. Below is a list of the available commands and their descriptions:</p>"},{"location":"plugins/cli.html#goose-cli","title":"Goose CLI","text":""},{"location":"plugins/cli.html#version","title":"<code>version</code>","text":"<p>Usage: <pre><code>  goose version\n</code></pre></p> <p>Lists the version of Goose and any associated plugins.</p>"},{"location":"plugins/cli.html#session","title":"<code>session</code>","text":""},{"location":"plugins/cli.html#start","title":"<code>start</code>","text":"<p>Usage: <pre><code>  goose session start [--profile PROFILE] [--plan PLAN] [--log-level [DEBUG|INFO|WARNING|ERROR|CRITICAL]] [--tracing]\n</code></pre></p> <p>Starts a new Goose session.</p> <p>If you want to enable locally hosted Langfuse tracing, pass the --tracing flag after starting your local Langfuse server as outlined in the Contributing Guide's Development guidelines.</p>"},{"location":"plugins/cli.html#resume","title":"<code>resume</code>","text":"<p>Usage: <pre><code>  goose session resume [NAME] [--profile PROFILE]\n</code></pre></p> <p>Resumes an existing Goose session.</p>"},{"location":"plugins/cli.html#list","title":"<code>list</code>","text":"<p>Usage: <pre><code>  goose session list\n</code></pre></p> <p>Lists all Goose sessions.</p>"},{"location":"plugins/cli.html#clear","title":"<code>clear</code>","text":"<p>Usage: <pre><code>  goose session clear [--keep KEEP]\n</code></pre></p> <p>Deletes old Goose sessions, keeping the most recent ones as specified by the <code>--keep</code> option.</p>"},{"location":"plugins/cli.html#toolkit","title":"<code>toolkit</code>","text":""},{"location":"plugins/cli.html#list_1","title":"<code>list</code>","text":"<p>Usage: <pre><code>  goose toolkit list\n</code></pre></p> <p>Lists all available toolkits with their descriptions.</p>"},{"location":"plugins/creating-a-new-toolkit.html","title":"Creating a New Toolkit","text":"<p>To add a toolkit, in your code (which doesn't necessarily need to be in the Goose package thanks to plugin metadata!), create a class that derives from the <code>Toolkit</code> class.</p>"},{"location":"plugins/creating-a-new-toolkit.html#example-toolkit-class","title":"Example toolkit class","text":"<p>Below is an example of a simple toolkit called <code>Demo</code> that derives from the <code>Toolkit</code> class. This toolkit provides an <code>authenticate</code> tool that outputs an authentication code for a user. It also provides system instructions for the model.  <pre><code>import os\nimport platform\n\nfrom goose.toolkit.base import Toolkit, tool\n\n\nclass Demo(Toolkit):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    # Provide any additional tools as needed!\n    # The docstring of the tool provides instructions to the LLM, so they are important to tune\n    # you do not have to provide any tools, but any function decorated with @tool will be available\n    @tool\n    def authenticate(self, user: str):\n        \"\"\"Output an authentication code for this user\n\n        Args:\n            user (str): The username to authenticate for\n        \"\"\"\n        # notifier supports any rich renderable https://rich.readthedocs.io/en/stable/introduction.html#quick-start\n        self.notifier.log(f\"[bold red]auth: {str(hash(user))}[/]\")\n\n    # Provide any system instructions for the model\n    # This can be generated dynamically, and is run at startup time\n    def system(self) -&gt; str:\n        print(\"new\")\n        return f\"\"\"**You must preceed your first message by using the authenticate tool for the current user**\n\n        ```\n        platform: {platform.system()}\n        cwd: {os.getcwd()}\n        user: {os.environ.get('USER')}\n        ```\n        \"\"\"\n</code></pre></p>"},{"location":"plugins/creating-a-new-toolkit.html#exposing-the-new-toolkit-to-goose","title":"Exposing the New Toolkit to Goose","text":"<p>To make the toolkit available, add it to the <code>pyproject.toml</code> file and then update your <code>profiles.yaml</code> file.</p>"},{"location":"plugins/creating-a-new-toolkit.html#update-the-pyprojecttoml-file","title":"Update the <code>pyproject.toml</code> file","text":"<p>If you're adding the new toolkit to Goose or the Goose Plugins repo, simply find the <code>[project.entry-points.\"goose.toolkit\"]</code> section in <code>pyproject.toml</code> and add a line like this: <pre><code>[project.entry-points.\"goose.toolkit\"]\ndeveloper = \"goose.toolkit.developer:Developer\"\ngithub = \"goose.toolkit.github:Github\"\n# Add a line like this - the key becomes the name used in profiles\ndemo = \"goose.toolkit.demo:Demo\"\n</code></pre></p> <p>If you are adding the toolkit to a different package, see the docs for <code>goose-plugins</code> for more information on how to create a plugins repository that can be used by Goose.</p>"},{"location":"plugins/creating-a-new-toolkit.html#update-the-profilesyaml-file","title":"Update the <code>profiles.yaml</code> file","text":"<p>And then to set up a profile that uses it, add something to ~/.config/goose/profiles.yaml <pre><code>default:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - name: developer\n      requires: {}\ndemo-profile:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: passive\n  toolkits:\n    - developer\n    - demo\n</code></pre></p> <p>And now you can run goose with this new profile to use the new toolkit!</p> <pre><code>goose session start --profile demo-profile\n</code></pre> <p>Note</p> <p>If you're using a plugin from <code>goose-plugins</code>, make sure <code>goose-plugins</code> is installed in your environment. You can install it via pip: </p> <p><code>pipx install goose-ai --preinstall goose-plugins</code></p>"},{"location":"plugins/plugins.html","title":"Plugins in Goose","text":"<p>Goose's functionality is extended via plugins. These plugins fall into three main categories:</p> <ol> <li>Toolkits: <ul> <li>Provides Goose with tools (functions) it can call and optionally will load additional context into the system prompt (such as 'The Github CLI is called via <code>gh</code> and you should use it to run git commands'). </li> <li>Toolkits can do basically anything, from calling external APIs, to taking a screenshot of your screen, to summarizing your current project.</li> </ul> </li> <li>CLI commands: <ul> <li>Provides additional commands to the Goose CLI. </li> <li>These commands can be used to interact with the Goose system, such as listing available toolkits or summarizing a session.</li> </ul> </li> <li>Providers: <ul> <li>Provides Goose with access to external LLMs. </li> <li>For example, the OpenAI provider allows Goose to interact with the OpenAI API. </li> <li>Most providers for Goose are defined in the Exchange library.</li> </ul> </li> </ol>"},{"location":"plugins/providers.html","title":"Providers","text":"<p>Providers in Goose mean \"LLM providers\" that Goose can interact with. Providers are defined in the Exchange library for the most part, but you can define your own.</p> <p>As you configure your chosen provider, you add the models you want to use to the <code>~/.config/goose/profiles.yaml</code> file and you can set any necessary environment variables or API keys in your terminal. For example:</p> <pre><code>export PROVIDER_API_KEY=\"your_api_key_here\"\n</code></pre>"},{"location":"plugins/providers.html#currently-available-providers","title":"Currently Available Providers","text":""},{"location":"plugins/providers.html#anthropic","title":"Anthropic","text":"<p>To use Anthropic, you need an API key, which you can obtain by signing up or logging into Anthropic's platform. Once you have your API key and your <code>profiles.yaml</code> file updated to the provider, you can set the <code>ANTHROPIC_API_KEY</code> environment variable in your shell using: </p> <pre><code>export ANTHROPIC_API_KEY=\"your_api_key_here\"`.\n</code></pre> profiles.yaml<pre><code>default:\n  provider: anthropic\n  processor: claude-3-5-sonnet-20241022\n  accelerator: claude-3-5-sonnet-20241022\n</code></pre>"},{"location":"plugins/providers.html#azure","title":"Azure","text":"<p>Azure AI services provide API keys through the Azure Portal. Visit the Azure Portal to create a resource and obtain your key. You will need to configure Goose by updating your profile and setting appropriate environment variables.</p> profiles.yaml<pre><code>default:\n  provider: azure\n  processor: azure-gpt-4\n  accelerator: azure-gpt-3\n</code></pre>"},{"location":"plugins/providers.html#bedrock","title":"Bedrock","text":"<p>More information can be found at AWS Bedrock. You need to set up your AWS credentials and configure Bedrock access accordingly in your Goose profile.</p> profiles.yaml<pre><code>default:\n  provider: bedrock\n  processor: titan-llm\n  accelerator: titan-llm-lite\n</code></pre>"},{"location":"plugins/providers.html#databricks","title":"Databricks","text":"<p>To use Databricks, sign up or log into Databricks and generate a personal access token via the user settings. Configure Goose by setting the <code>DATABRICKS_HOST</code> and <code>DATABRICKS_TOKEN</code> environment variables.</p> profiles.yaml<pre><code>default:\n  provider: databricks\n  processor: databricks-meta-llama-3-1-70b-instruct\n  accelerator: databricks-meta-llama-3-1-70b-instruct\n</code></pre>"},{"location":"plugins/providers.html#google","title":"Google","text":"<p>Google Cloud AI services require you to set up a project in the Google Cloud Console. After enabling the relevant APIs, you should generate an API key or set up a service account. Ensure your application can access these credentials.</p> profiles.yaml<pre><code>default:\n  provider: google\n  processor: gemini-1.5-flash\n  accelerator: gemini-1.5-flash\n</code></pre>"},{"location":"plugins/providers.html#ollama","title":"Ollama","text":"<p>For Ollama, refer to the setup process on Ollama's site for obtaining necessary credentials. Make sure your environment has all the required tokens set up.</p> profiles.yaml<pre><code>default:\n  provider: ollama\n  processor: ollama-pro\n  accelerator: ollama-lite\n</code></pre>"},{"location":"plugins/providers.html#openai","title":"OpenAI","text":"<p>Register at OpenAI's platform to obtain an API key. Configure Goose by updating your <code>profiles.yaml</code> file and setting the <code>OPENAI_API_KEY</code> in your terminal: </p> <pre><code>export OPENAI_API_KEY=\"your_api_key_here\"\n</code></pre> profiles.yaml<pre><code>default:\n  provider: openai\n  processor: gpt-4\n  accelerator: gpt-3.5-turbo\n</code></pre>"},{"location":"plugins/using-toolkits.html","title":"Using Toolkits","text":"<p>Toolkits in Goose are add-ons that expand its capabilities, offering tools and prompts for specific tasks. They make it easier to interact with external systems and handle complex operations. In this guide, we'll cover how to use toolkits included in <code>goose</code> and those available through the <code>goose-plugins</code> repository.</p> <p>Important</p> <p>Before using toolkits, ensure Goose is installed and properly set up. If you haven\u2019t installed Goose yet, follow the Goose Installation Guide.    </p>"},{"location":"plugins/using-toolkits.html#listing-available-toolkits","title":"Listing Available Toolkits","text":"<p>To list available toolkits, use the following command within the Goose repo:</p> <pre><code>goose toolkit list\n</code></pre> <p>This will display a list of all toolkits available in your environment.</p> <p>The output should look similar to the following: </p> <pre><code>Available toolkits:\n - browser: A toolkit for interacting with web browsers using Selenium.\n - github: Provides an additional prompt on how to interact with Github\n - jira: Provides an additional prompt on how to interact with Jira\n - reasoner: Deep thinking toolkit for reasoning through problems and solutions\n - repo_context: Provides context about the current repository\n - screen: Provides an instructions on when and how to work with screenshots\n - synopsis: Provides shell and file operation tools using OperatingSystem.\n - codesearch: Provides a way of searching through internal company code.\n - glean: Provides Goose with access to Glean, our AI search vendor.\n - java: Provides guidance on how to work in Java codebases\n - migrate-prefect: Enabled Goose to automate the Prefect 2 migration\n</code></pre> <p>The list above is limited. For a complete list, refer to the Goose Available Toolkits Guide.</p>"},{"location":"plugins/using-toolkits.html#adding-toolkits-to-a-profile","title":"Adding Toolkits to a Profile","text":"<p>To use a Toolkit within your Goose sessions, you'll need to add them to the <code>profiles.yaml</code> file, which can be found in your <code>User</code> directory at <code>~/.config/goose/profiles.yaml</code>. Here's how to add multiple toolkits:</p> profiles.yaml<pre><code>default:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: synopsis\n  toolkits:\n    - name: synopsis\n      requires: {}\n    - name: my_toolkit\n      requires: {}\n</code></pre> <p>Important</p> <p>You always want to have the <code>synopsis</code> Toolkit, formerly known as the <code>developer</code> Toolkit enabled. It is essential for Goose to be able to create files for you, if this is removed it will greatly limit Goose's functionality. </p> <p>Additionally, use the <code>requires</code> field to specify dependencies between toolkits, and any necessary configurations. If there are no requirements, simply add an empty set of braces: <code>{}</code>. </p>"},{"location":"plugins/using-toolkits.html#starting-a-goose-session-with-toolkits","title":"Starting a Goose Session with Toolkits","text":"<p>Once your profile is set up, you can start a Goose session with the specified profile. You can configure multiple profiles in your profiles.yaml file to suit different needs. For example, you might have separate <code>default</code> and <code>work</code> profiles:</p> profiles.yaml<pre><code>default:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: synopsis\n  toolkits:\n  - name: synopsis\n    requires: {}\n  - name: screen\n    requires: {}\nwork:\n  provider: block\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: synopsis\n  toolkits:\n  - name: synopsis\n    requires: {}\n  - name: jira\n    requires: {}\n</code></pre> <p>In the example above: - The <code>default</code> profile uses the <code>synopsis</code>, and <code>screen</code> toolkits. - The <code>work</code> profile is configured with the <code>synopsis</code> and <code>jira</code> toolkits.</p> <p>To start a session with the <code>work</code> profile, run: </p> <p><pre><code>goose session start --profile work\n</code></pre> If your <code>profile.yaml</code> file contains only one profile, you can simply run: </p> <pre><code>goose session start\n</code></pre>"},{"location":"plugins/using-toolkits.html#using-toolkits-from-goose-plugins","title":"Using Toolkits from Goose Plugins","text":"<p>Goose comes with a default set of toolkits for essential functionality. For more specialized tasks and integrations, the <code>goose-plugins</code> repository provides optional toolkits that you can add as needed. This allows you to customize Goose to match your specific workflows without overloading the core installation.</p> <p>To access these additional toolkits, follow these steps:</p>"},{"location":"plugins/using-toolkits.html#install-goose-plugins","title":"Install <code>goose-plugins</code>:","text":"<p>Run the following command to install the <code>goose-plugins</code> package:</p> <pre><code> pipx install goose-ai --preinstall goose-plugins\n</code></pre>"},{"location":"plugins/using-toolkits.html#list-available-toolkits","title":"List available toolkits:","text":"<p>Within the <code>goose-plugins</code> repo, you may need to install <code>uv</code> first. </p> <pre><code>uv run goose toolkit list\n</code></pre>"},{"location":"plugins/using-toolkits.html#update-the-profilesyaml-file","title":"Update the <code>profiles.yaml</code> File:","text":"<p>Add the desired Toolkit from the <code>goose-plugins</code> repository to your profile. For example:</p> profiles.yaml<pre><code>default:\n  provider: openai\n  processor: gpt-4o\n  accelerator: gpt-4o-mini\n  moderator: synopsis\n  toolkits:\n    - name: synopsis                                                                                                             \n      requires: {}   \n    - name: jira\n      requires: {}\n</code></pre>"},{"location":"plugins/using-toolkits.html#start-the-goose-session","title":"Start the Goose Session:","text":"<pre><code>goose session start --profile default\n</code></pre>"},{"location":"reference/index.html","title":"Reference Documentation","text":""},{"location":"reference/index.html#goose","title":"Goose","text":"<ul> <li>goose.build</li> <li>goose.notifier</li> <li>goose.profile</li> <li>goose.view</li> </ul>"},{"location":"reference/index.html#command","title":"Command","text":"<ul> <li>goose.command.base</li> <li>goose.command.file</li> </ul>"},{"location":"reference/index.html#cli","title":"CLI","text":"<ul> <li>goose.cli.config</li> <li>goose.cli.main</li> <li>goose.cli.prompt.create</li> <li>goose.cli.prompt.goose_prompt_session</li> <li>goose.cli.session</li> </ul>"},{"location":"reference/index.html#toolkits","title":"Toolkits","text":"<p>goose.toolkit.base - goose.toolkit.developer - goose.toolkit.github - goose.toolkit.repo_context.repo_context - goose.toolkit.repo_context.utils - goose.toolkit.screen - goose.toolkit.summarization.summarize_file - goose.toolkit.summarization.summarize_project - goose.toolkit.summarization.summarize_repo - goose.toolkit.summarization.utils - goose.toolkit.utils</p>"},{"location":"reference/index.html#utils","title":"Utils","text":"<ul> <li>goose.utils</li> <li>goose.utils.ask</li> <li>goose.utils.file_utils</li> <li>goose.utils.session_file</li> <li>goose.utils.shell.is_dangerous_command</li> </ul>"},{"location":"reference/goose/index.html","title":"Index","text":""},{"location":"reference/goose/build.html","title":"Build","text":""},{"location":"reference/goose/build.html#goose.build.build_exchange","title":"<code>build_exchange(profile, notifier)</code>","text":"<p>Build an exchange configured through the profile</p> <p>This will setup any toolkits and use that to build the exchange's collection of tools.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Profile</code> <p>The profile specifying how to setup this exchange</p> required <code>notifier</code> <code>Notifier</code> <p>A notifier instance used by tools to send info</p> required Source code in <code>src/goose/build.py</code> <pre><code>def build_exchange(profile: Profile, notifier: Notifier) -&gt; Exchange:\n    \"\"\"Build an exchange configured through the profile\n\n    This will setup any toolkits and use that to build the exchange's collection\n    of tools.\n\n    Args:\n        profile (Profile): The profile specifying how to setup this exchange\n        notifier (Notifier): A notifier instance used by tools to send info\n    \"\"\"\n\n    provider = get_provider(profile.provider).from_env()\n\n    # Support instantating toolkits in *two* passes for now, no further nesting\n    concrete_toolkits = {}\n\n    # First instantiate all toolkits that are sub dependencies\n    for spec in profile.toolkits:\n        for required in spec.requires.values():\n            concrete_toolkits[required] = get_toolkit(required)(notifier=notifier, requires=Requirements(required))\n\n    # Now that we have the dependencies available, we can instantiate everything else\n    toolkits = []\n    for spec in profile.toolkits:\n        if spec.name in concrete_toolkits:\n            toolkits.append(concrete_toolkits[spec.name])\n            continue\n\n        requires = Requirements(\n            spec.name,\n            {key: concrete_toolkits[val] for key, val in spec.requires.items()},\n        )\n        toolkit = get_toolkit(spec.name)(notifier=notifier, requires=requires)\n        toolkits.append(toolkit)\n\n    # From the toolkits, we derive the exchange prompt and tools\n    system = \"\\n\\n\".join([Message.load(\"system.jinja\").text] + [toolkit.system() for toolkit in toolkits])\n    tools = tuple(chain(*(toolkit.tools() for toolkit in toolkits)))\n    exchange = Exchange(\n        provider=provider,\n        system=system,\n        tools=tools,\n        moderator=get_moderator(profile.moderator)(),\n        model=profile.processor,\n    )\n\n    # This is a bit awkward, but we have to set this after the fact because building\n    # the exchange requires having the toolkits\n    for toolkit in toolkits:\n        toolkit.exchange_view = ExchangeView(profile.processor, profile.accelerator, exchange)\n\n    return exchange\n</code></pre>"},{"location":"reference/goose/notifier.html","title":"Notifier","text":""},{"location":"reference/goose/notifier.html#goose.notifier.Notifier","title":"<code>Notifier</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The interface for a notifier</p> <p>This is expected to be implemented concretely by the each UX</p> Source code in <code>src/goose/notifier.py</code> <pre><code>class Notifier(ABC):\n    \"\"\"The interface for a notifier\n\n    This is expected to be implemented concretely by the each UX\n    \"\"\"\n\n    @abstractmethod\n    def log(self, content: RenderableType) -&gt; None:\n        \"\"\"Append content to the main display\n\n        Args:\n            content (str): The content to render\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def status(self, status: Optional[str]) -&gt; None:\n        \"\"\"Log a status to ephemeral display\n\n        Args:\n            status (str): The status to display\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def start(self) -&gt; None:\n        \"\"\"Start the display for the notifier\"\"\"\n        pass\n\n    @abstractmethod\n    def stop(self) -&gt; None:\n        \"\"\"Stop the display for the notifier\"\"\"\n        pass\n</code></pre>"},{"location":"reference/goose/notifier.html#goose.notifier.Notifier.log","title":"<code>log(content)</code>  <code>abstractmethod</code>","text":"<p>Append content to the main display</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to render</p> required Source code in <code>src/goose/notifier.py</code> <pre><code>@abstractmethod\ndef log(self, content: RenderableType) -&gt; None:\n    \"\"\"Append content to the main display\n\n    Args:\n        content (str): The content to render\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/notifier.html#goose.notifier.Notifier.start","title":"<code>start()</code>  <code>abstractmethod</code>","text":"<p>Start the display for the notifier</p> Source code in <code>src/goose/notifier.py</code> <pre><code>@abstractmethod\ndef start(self) -&gt; None:\n    \"\"\"Start the display for the notifier\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/notifier.html#goose.notifier.Notifier.status","title":"<code>status(status)</code>  <code>abstractmethod</code>","text":"<p>Log a status to ephemeral display</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>The status to display</p> required Source code in <code>src/goose/notifier.py</code> <pre><code>@abstractmethod\ndef status(self, status: Optional[str]) -&gt; None:\n    \"\"\"Log a status to ephemeral display\n\n    Args:\n        status (str): The status to display\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/notifier.html#goose.notifier.Notifier.stop","title":"<code>stop()</code>  <code>abstractmethod</code>","text":"<p>Stop the display for the notifier</p> Source code in <code>src/goose/notifier.py</code> <pre><code>@abstractmethod\ndef stop(self) -&gt; None:\n    \"\"\"Stop the display for the notifier\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/profile.html","title":"Profile","text":""},{"location":"reference/goose/profile.html#goose.profile.ObserverSpec","title":"<code>ObserverSpec</code>","text":"<p>Configuration for an Observer (telemetry plugin)</p> Source code in <code>src/goose/profile.py</code> <pre><code>@define\nclass ObserverSpec:\n    \"\"\"Configuration for an Observer (telemetry plugin)\"\"\"\n\n    name: str\n</code></pre>"},{"location":"reference/goose/profile.html#goose.profile.Profile","title":"<code>Profile</code>","text":"<p>The configuration for a run of goose</p> Source code in <code>src/goose/profile.py</code> <pre><code>@define\nclass Profile:\n    \"\"\"The configuration for a run of goose\"\"\"\n\n    provider: str\n    processor: str\n    accelerator: str\n    moderator: str\n    toolkits: list[ToolkitSpec] = field(factory=list, converter=ensure_list(ToolkitSpec))\n    observers: list[ObserverSpec] = field(factory=list, converter=ensure_list(ObserverSpec))\n\n    @toolkits.validator\n    def check_toolkit_requirements(self, _: type[\"ToolkitSpec\"], toolkits: list[ToolkitSpec]) -&gt; None:\n        # checks that the list of toolkits in the profile have their requirements\n        installed_toolkits = set([toolkit.name for toolkit in toolkits])\n\n        for toolkit in toolkits:\n            toolkit_name = toolkit.name\n            toolkit_requirements = toolkit.requires\n            for _, req in toolkit_requirements.items():\n                if req not in installed_toolkits:\n                    msg = f\"Toolkit {toolkit_name} requires {req} but it is not present\"\n                    raise ValueError(msg)\n\n    def to_dict(self) -&gt; dict[str, any]:\n        return asdict(self)\n\n    def profile_info(self) -&gt; str:\n        toolkit_names = [toolkit.name for toolkit in self.toolkits]\n        observer_names = [observer.name for observer in self.observers]\n        return (\n            f\"provider:{self.provider}, processor:{self.processor} \"\n            f\"toolkits: {', '.join(toolkit_names)} \"\n            f\"observers: {', '.join(observer_names)}\"\n        )\n</code></pre>"},{"location":"reference/goose/profile.html#goose.profile.ToolkitSpec","title":"<code>ToolkitSpec</code>","text":"<p>Configuration for a Toolkit</p> Source code in <code>src/goose/profile.py</code> <pre><code>@define\nclass ToolkitSpec:\n    \"\"\"Configuration for a Toolkit\"\"\"\n\n    name: str\n    requires: Mapping[str, str] = field(factory=dict)\n</code></pre>"},{"location":"reference/goose/profile.html#goose.profile.default_profile","title":"<code>default_profile(provider, processor, accelerator, **kwargs)</code>","text":"<p>Get the default profile</p> Source code in <code>src/goose/profile.py</code> <pre><code>def default_profile(provider: str, processor: str, accelerator: str, **kwargs: dict[str, any]) -&gt; Profile:\n    \"\"\"Get the default profile\"\"\"\n\n    # TODO consider if the providers should have recommended models\n\n    return Profile(\n        provider=provider,\n        processor=processor,\n        accelerator=accelerator,\n        moderator=\"synopsis\",\n        toolkits=[ToolkitSpec(\"synopsis\")],\n        observers=[ObserverSpec(\"langfuse\")],\n    )\n</code></pre>"},{"location":"reference/goose/view.html","title":"View","text":""},{"location":"reference/goose/view.html#goose.view.ExchangeView","title":"<code>ExchangeView</code>","text":"<p>A read-only view of the underlying Exchange</p> <p>Attributes:</p> Name Type Description <code>processor</code> <code>Exchange</code> <p>A copy of the exchange configured for high capabilities</p> <code>accelerator</code> <code>Exchange</code> <p>A copy of the exchange configured for high speed</p> Source code in <code>src/goose/view.py</code> <pre><code>@define\nclass ExchangeView:\n    \"\"\"A read-only view of the underlying Exchange\n\n\n    Attributes:\n        processor: A copy of the exchange configured for high capabilities\n        accelerator: A copy of the exchange configured for high speed\n\n    \"\"\"\n\n    _processor: str\n    _accelerator: str\n    _exchange: Exchange\n\n    @property\n    def processor(self) -&gt; Exchange:\n        return self._exchange.replace(model=self._processor)\n\n    @property\n    def accelerator(self) -&gt; Exchange:\n        return self._exchange.replace(model=self._accelerator)\n</code></pre>"},{"location":"reference/goose/cli/index.html","title":"Index","text":""},{"location":"reference/goose/cli/config.html","title":"Config","text":""},{"location":"reference/goose/cli/config.html#goose.cli.config.ensure_config","title":"<code>ensure_config(name)</code>","text":"<p>Ensure that the config exists and has the default section</p> Source code in <code>src/goose/cli/config.py</code> <pre><code>def ensure_config(name: Optional[str]) -&gt; tuple[str, Profile]:\n    \"\"\"Ensure that the config exists and has the default section\"\"\"\n    # TODO we should copy a templated default config in to better document\n    # but this is complicated a bit by autodetecting the provider\n    default_profile_name = \"default\"\n    name = name or default_profile_name\n    default_profiles_dict = default_profiles()\n    provider, processor, accelerator = default_model_configuration()\n    default_profile = default_profiles_dict.get(name, default_profiles_dict[default_profile_name])(\n        provider, processor, accelerator\n    )\n\n    if not PROFILES_CONFIG_PATH.exists():\n        print(\n            Panel(\n                f\"[yellow]No configuration present, we will create a profile '{name}'\"\n                + f\" at: [/]{str(PROFILES_CONFIG_PATH)}\\n\"\n                + \"You can add your own profile in this file to further configure goose!\"\n            )\n        )\n        write_config({name: default_profile})\n        return (name, default_profile)\n\n    profiles = read_config()\n    if name in profiles:\n        return (name, profiles[name])\n    print(Panel(f\"[yellow]Your configuration doesn't have a profile named '{name}', adding one now[/yellow]\"))\n    profiles.update({name: default_profile})\n    write_config(profiles)\n    return (name, default_profile)\n</code></pre>"},{"location":"reference/goose/cli/config.html#goose.cli.config.read_config","title":"<code>read_config()</code>","text":"<p>Return config from the configuration file and validates its contents</p> Source code in <code>src/goose/cli/config.py</code> <pre><code>def read_config() -&gt; dict[str, Profile]:\n    \"\"\"Return config from the configuration file and validates its contents\"\"\"\n\n    yaml = YAML()\n    with PROFILES_CONFIG_PATH.open(\"r\") as f:\n        data = yaml.load(f)\n\n    return {name: Profile(**profile) for name, profile in data.items()}\n</code></pre>"},{"location":"reference/goose/cli/config.html#goose.cli.config.write_config","title":"<code>write_config(profiles)</code>","text":"<p>Overwrite the config with the passed profiles</p> Source code in <code>src/goose/cli/config.py</code> <pre><code>def write_config(profiles: dict[str, Profile]) -&gt; None:\n    \"\"\"Overwrite the config with the passed profiles\"\"\"\n    PROFILES_CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)\n    converted = {name: profile.to_dict() for name, profile in profiles.items()}\n    yaml = YAML()\n    with PROFILES_CONFIG_PATH.open(\"w\") as f:\n        yaml.dump(converted, f)\n</code></pre>"},{"location":"reference/goose/cli/main.html","title":"Main","text":""},{"location":"reference/goose/cli/main.html#goose.cli.main.get_version","title":"<code>get_version()</code>","text":"<p>Lists the version of goose and any plugins</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.command(name=\"version\")\ndef get_version() -&gt; None:\n    \"\"\"Lists the version of goose and any plugins\"\"\"\n    from importlib.metadata import entry_points, version\n\n    print(f\"[green]Goose-ai[/green]: [bold][cyan]{version('goose-ai')}[/cyan][/bold]\")\n    print(\"[green]Plugins[/green]:\")\n    entry_points = entry_points(group=\"metadata.plugins\")\n    modules = set()\n\n    for ep in entry_points:\n        module_name = ep.name\n        modules.add(module_name)\n    modules.remove(\"goose-ai\")\n    for module in sorted(list(modules)):\n        # TODO: figure out how to get this to work for goose plugins block\n        # as the module name is set to block.goose.cli\n        # module_name = 'goose-plugins-block'\n        try:\n            module_version = version(module)\n            print(f\"  Module: [green]{module}[/green], Version: [bold][cyan]{module_version}[/cyan][/bold]\")\n        except Exception as e:\n            print(f\"  [red]Could not retrieve version for {module}: {e}[/red]\")\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.list_moderators","title":"<code>list_moderators()</code>","text":"<p>List available moderators</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@moderators.command(name=\"list\")\ndef list_moderators() -&gt; None:\n    \"\"\"List available moderators\"\"\"\n    from exchange.moderators import load_plugins\n\n    moderators = load_plugins(group=\"exchange.moderator\")\n\n    print(\"[green]Available moderators:[/green]\")\n    for moderator_name, moderator in moderators.items():\n        lines_doc = moderator.__doc__.split(\"\\n\") if moderator.__doc__ else [\"No description available\"]\n        first_line_of_doc = lines_doc[0]\n        print(f\" - [bold]{moderator_name}[/bold]: {first_line_of_doc}\")\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.moderators","title":"<code>moderators()</code>","text":"<p>Manage moderators</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.group()\ndef moderators() -&gt; None:\n    \"\"\"Manage moderators\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.providers","title":"<code>providers()</code>","text":"<p>Manage providers</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.group()\ndef providers() -&gt; None:\n    \"\"\"Manage providers\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.run","title":"<code>run(message_file, profile, log_level, resume_session=False, tracing=False)</code>","text":"<p>Run a single-pass session with a message from a markdown input file</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.command(name=\"run\")\n@click.argument(\"message_file\", required=False, type=click.Path(exists=True))\n@click.option(\"--profile\")\n@click.option(\"--log-level\", type=LOG_CHOICE, default=\"INFO\")\n@click.option(\"--resume-session\", is_flag=True, help=\"Resume the last session if available\")\n@click.option(\"--tracing\", is_flag=True, required=False)\ndef run(\n    message_file: Optional[str],\n    profile: str,\n    log_level: str,\n    resume_session: bool = False,\n    tracing: bool = False,\n) -&gt; None:\n    \"\"\"Run a single-pass session with a message from a markdown input file\"\"\"\n    if message_file:\n        with open(message_file, \"r\") as f:\n            initial_message = f.read()\n    else:\n        initial_message = click.get_text_stream(\"stdin\").read()\n\n    if resume_session:\n        session_files = get_session_files()\n        if session_files:\n            name = list(session_files.keys())[0]\n            session = Session(name=name, profile=profile, log_level=log_level, tracing=tracing)\n    else:\n        session = Session(profile=profile, log_level=log_level, tracing=tracing)\n    session.single_pass(initial_message=initial_message)\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session","title":"<code>session()</code>","text":"<p>Start or manage sessions</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.group()\ndef session() -&gt; None:\n    \"\"\"Start or manage sessions\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session_clear","title":"<code>session_clear(keep)</code>","text":"<p>Delete old goose sessions, keeping the most recent sessions up to the specified number</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@session.command(name=\"clear\")\n@click.option(\"--keep\", default=3, help=\"Keep this many entries, default 3\")\ndef session_clear(keep: int) -&gt; None:\n    \"\"\"Delete old goose sessions, keeping the most recent sessions up to the specified number\"\"\"\n    for i, (_, session_file) in enumerate(get_session_files().items()):\n        if i &gt;= keep:\n            session_file.unlink()\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session_list","title":"<code>session_list()</code>","text":"<p>List goose sessions</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@session.command(name=\"list\")\ndef session_list() -&gt; None:\n    \"\"\"List goose sessions\"\"\"\n    session_files = get_session_files().items()\n    for session_name, session_file in session_files:\n        print(f\"{datetime.fromtimestamp(session_file.stat().st_mtime).strftime('%Y-%m-%d %H:%M:%S')}    {session_name}\")\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session_resume","title":"<code>session_resume(name, profile, log_level)</code>","text":"<p>Resume an existing goose session</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@session.command(name=\"resume\")\n@click.argument(\"name\", required=False, shell_complete=autocomplete_session_files)\n@click.option(\"--profile\")\n@click.option(\"--log-level\", type=LOG_CHOICE, default=\"INFO\")\ndef session_resume(name: Optional[str], profile: str, log_level: str) -&gt; None:\n    \"\"\"Resume an existing goose session\"\"\"\n    session_files = get_session_files()\n    if name is None:\n        if session_files:\n            name = list(session_files.keys())[0]\n            print(f\"Resuming most recent session: {name} from {session_files[name]}\")\n        else:\n            print(\"No sessions found.\")\n            return\n    else:\n        if name in session_files:\n            print(f\"Resuming session: {name}\")\n        else:\n            print(f\"Creating new session: {name}\")\n    session = Session(name=name, profile=profile, log_level=log_level)\n    session.run(new_session=False)\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.session_start","title":"<code>session_start(name, profile, log_level, plan=None, tracing=False)</code>","text":"<p>Start a new goose session</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@session.command(name=\"start\")\n@click.argument(\"name\", required=False, shell_complete=autocomplete_session_files)\n@click.option(\"--profile\")\n@click.option(\"--plan\", type=click.Path(exists=True))\n@click.option(\"--log-level\", type=click.Choice([\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]), default=\"INFO\")\n@click.option(\"--tracing\", is_flag=True, required=False)\ndef session_start(\n    name: Optional[str], profile: str, log_level: str, plan: Optional[str] = None, tracing: bool = False\n) -&gt; None:\n    \"\"\"Start a new goose session\"\"\"\n    if plan:\n        yaml = YAML()\n        with open(plan, \"r\") as f:\n            _plan = yaml.load(f)\n    else:\n        _plan = None\n\n    try:\n        session = Session(name=name, profile=profile, plan=_plan, log_level=log_level, tracing=tracing)\n        session.run()\n    except RuntimeError as e:\n        print(f\"[red]Error: {e}\")\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.shell_completions","title":"<code>shell_completions(ctx, install, generate, shell)</code>","text":"<p>Generate or install shell completions for goose</p> <p>Parameters:</p> Name Type Description Default <code>shell</code> <code>str</code> <p>shell to install completions for</p> required <code>install</code> <code>bool</code> <p>installs completions if true, otherwise generates             completions</p> required Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.command(name=\"shell-completions\", help=\"Manage shell completions for goose\")\n@click.option(\"--install\", is_flag=True, help=\"Install shell completions\")\n@click.option(\"--generate\", is_flag=True, help=\"Generate shell completions\")\n@click.argument(\n    \"shell\",\n    type=click.Choice(SUPPORTED_SHELLS),\n    default=get_current_shell(),\n)\n@click.pass_context\ndef shell_completions(ctx: click.Context, install: bool, generate: bool, shell: str) -&gt; None:\n    \"\"\"Generate or install shell completions for goose\n\n    Args:\n        shell (str): shell to install completions for\n        install (bool): installs completions if true, otherwise generates\n                        completions\n    \"\"\"\n    if not any([install, generate]):\n        print(\"[red]One of --install or --generate must be specified[/red]\\n\")\n        raise click.UsageError(ctx.get_help())\n\n    if sum([install, generate]) &gt; 1:\n        print(\"[red]Only one of --install or --generate can be specified[/red]\\n\")\n        raise click.UsageError(ctx.get_help())\n\n    setup_autocomplete(shell, install=install)\n</code></pre>"},{"location":"reference/goose/cli/main.html#goose.cli.main.toolkit","title":"<code>toolkit()</code>","text":"<p>Manage toolkits</p> Source code in <code>src/goose/cli/main.py</code> <pre><code>@goose_cli.group()\ndef toolkit() -&gt; None:\n    \"\"\"Manage toolkits\"\"\"\n    pass\n</code></pre>"},{"location":"reference/goose/cli/session.html","title":"Session","text":""},{"location":"reference/goose/cli/session.html#goose.cli.session.Session","title":"<code>Session</code>","text":"<p>A session handler for managing interactions between a user and the Goose exchange</p> <p>This class encapsulates the entire user interaction cycle, from input prompt to response handling, including interruptions and error management.</p> Source code in <code>src/goose/cli/session.py</code> <pre><code>class Session:\n    \"\"\"A session handler for managing interactions between a user and the Goose exchange\n\n    This class encapsulates the entire user interaction cycle, from input prompt to response handling,\n    including interruptions and error management.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        profile: Optional[str] = None,\n        plan: Optional[dict] = None,\n        log_level: Optional[str] = \"INFO\",\n        tracing: bool = False,\n        **kwargs: dict[str, any],\n    ) -&gt; None:\n        if name is None:\n            self.name = droid()\n        else:\n            self.name = name\n        self.profile_name = profile\n        self.prompt_session = GoosePromptSession()\n        self.status_indicator = Status(\"\", spinner=\"dots\")\n        self.notifier = SessionNotifier(self.status_indicator)\n        self.has_plan = plan is not None\n        self.tracing = tracing\n\n        self.exchange = create_exchange(profile=load_profile(profile), notifier=self.notifier)\n        setup_logging(log_file_directory=LOG_PATH, log_level=log_level)\n\n        all_observers = load_plugins(group=\"exchange.observer\")\n        profile_observer_names = load_profile(profile).observers\n        observers_to_init = [all_observers[o.name]() for o in profile_observer_names if o.name in all_observers]\n\n        self.observer_manager = ObserverManager.get_instance()\n        self.observer_manager.initialize(tracing=tracing, observers=observers_to_init)\n\n        self.exchange.messages.extend(self._get_initial_messages())\n\n        if len(self.exchange.messages) == 0 and plan:\n            self.setup_plan(plan=plan)\n\n        self.prompt_session = GoosePromptSession()\n\n    def __del__(self) -&gt; None:\n        if hasattr(self, \"observer_manager\"):\n            self.observer_manager.finalize()\n\n    def _get_initial_messages(self) -&gt; list[Message]:\n        messages = self.load_session()\n\n        if messages and messages[-1].role == \"user\":\n            if type(messages[-1].content[-1]) is Text:\n                # remove the last user message\n                messages.pop()\n            elif type(messages[-1].content[-1]) is ToolResult:\n                # if we remove this message, we would need to remove\n                # the previous assistant message as well. instead of doing\n                # that, we just add a new assistant message to prompt the user\n                messages.append(Message.assistant(RESUME_MESSAGE))\n        if messages and type(messages[-1].content[-1]) is ToolUse:\n            # remove the last request for a tool to be used\n            messages.pop()\n\n            # add a new assistant text message to prompt the user\n            messages.append(Message.assistant(RESUME_MESSAGE))\n        return messages\n\n    def setup_plan(self, plan: dict) -&gt; None:\n        if len(self.exchange.messages):\n            raise ValueError(\"The plan can only be set on an empty session.\")\n\n        # we append the plan to the kickoff message for now. We should\n        # revisit this if we intend plans to be handled in a consistent way across toolkits\n        plan_steps = \"\\n\" + \"\\n\".join(f\"{i}. {t}\" for i, t in enumerate(plan[\"tasks\"]))\n\n        message = Message.user(plan[\"kickoff_message\"] + plan_steps)\n        self.exchange.add(message)\n\n    def process_first_message(self) -&gt; Optional[Message]:\n        # Get a first input unless it has been specified, such as by a plan\n        if len(self.exchange.messages) == 0 or self.exchange.messages[-1].role == \"assistant\":\n            user_input = self.prompt_session.get_user_input()\n            if user_input.to_exit():\n                return None\n            return Message.user(text=user_input.text)\n        return self.exchange.messages.pop()\n\n    def single_pass(self, initial_message: Optional[str]) -&gt; None:\n        \"\"\"\n        Handles a single input message and processes a reply\n        without entering a loop for additional inputs.\n\n        Args:\n            initial_message (Optional[str]): The initial user message to process.\n        \"\"\"\n        profile = self.profile_name or \"default\"\n        print(f\"[dim]starting session | name: [cyan]{self.name}[/]  profile: [cyan]{profile}[/]\")\n        print(f\"[dim]saving to {self.session_file_path}\")\n\n        # Check to see if there is a planned operation to perform prior to the bespoke prompt\n        if self.has_plan and len(self.exchange.messages) &gt; 0:\n            # Process the plan prompt\n            self.exchange.add(self.exchange.messages.pop())\n            self.reply()\n\n        if initial_message:\n            # Process initial message\n            message = Message.user(initial_message)\n\n            self.exchange.add(message)\n            self.reply()  # Process the user message\n\n        print(f\"[dim]ended run | name: [cyan]{self.name}[/]  profile: [cyan]{profile}[/]\")\n        print(f\"[dim]to resume: [magenta]goose session resume {self.name} --profile {profile}[/][/]\")\n\n    def run(self, new_session: bool = True) -&gt; None:\n        \"\"\"\n        Runs the main loop to handle user inputs and responses.\n        Continues until an empty string is returned from the prompt.\n\n        Args:\n            new_session (bool): True when starting a new session, False when resuming.\n        \"\"\"\n        time_start = datetime.now()\n        if is_existing_session(self.session_file_path) and new_session:\n            self._prompt_overwrite_session()\n\n        profile_name = self.profile_name or \"default\"\n        print(f\"[dim]starting session | name: [cyan]{self.name}[/cyan]  profile: [cyan]{profile_name}[/cyan][/dim]\")\n        print()\n        message = self.process_first_message()\n        while message:  # Loop until no input (empty string).\n            self.notifier.start()\n            try:\n                self.exchange.add(message)\n                self.reply()  # Process the user message.\n            except Exception:\n                # rewind to right before the last user message\n                self.exchange.rewind()\n                print(traceback.format_exc())\n                print(\n                    \"\\n[red]The error above was an exception we were not able to handle.\\n\\n[/]\"\n                    + \"These errors are often related to connection or authentication\\n\"\n                    + \"We've removed the conversation up to the most recent user message\"\n                    + \" - [yellow]depending on the error you may be able to continue[/]\"\n                )\n            self.notifier.stop()\n            print()  # Print a newline for separation.\n            user_input = self.prompt_session.get_user_input()\n            message = Message.user(text=user_input.text) if user_input.to_continue() else None\n\n        self._remove_empty_session()\n        time_end = datetime.now()\n        self._log_cost(start_time=time_start, end_time=time_end)\n\n    @observe_wrapper(session_id=lambda instance: instance.name)\n    def reply(self) -&gt; None:\n        \"\"\"Reply to the last user message, calling tools as needed\"\"\"\n        # These are the *raw* messages, before the moderator rewrites things\n        committed = [self.exchange.messages[-1]]\n\n        try:\n            self.status_indicator.update(\"processing request\")\n            response = self.exchange.generate()\n            self.status_indicator.update(\"got response, processing\")\n            committed.append(response)\n\n            if response.text:\n                print(Markdown(response.text))\n\n            while response.tool_use:\n                content = []\n                for tool_use in response.tool_use:\n                    tool_result = self.exchange.call_function(tool_use)\n                    content.append(tool_result)\n                message = Message(role=\"user\", content=content)\n                committed.append(message)\n                self.exchange.add(message)\n                self.status_indicator.update(\"processing tool results\")\n                response = self.exchange.generate()\n                committed.append(response)\n\n                if response.text:\n                    print(Markdown(response.text))\n        except KeyboardInterrupt:\n            # The interrupt reply modifies the message history,\n            # and we sync those changes to committed\n            self.interrupt_reply(committed)\n\n        # we log the committed messages only once the reply completes\n        # this prevents messages related to uncaught errors from being recorded\n        log_messages(self.session_file_path, committed)\n\n    def interrupt_reply(self, committed: list[Message]) -&gt; None:\n        \"\"\"Recover from an interruption at an arbitrary state\"\"\"\n        # Default recovery message if no user message is pending.\n        recovery = \"We interrupted before the next processing started.\"\n        if self.exchange.messages and self.exchange.messages[-1].role == \"user\":\n            # If the last message is from the user, remove it.\n            self.exchange.messages.pop()\n            committed.pop()\n            recovery = \"We interrupted before the model replied and removed the last message.\"\n\n        if (\n            self.exchange.messages\n            and self.exchange.messages[-1].role == \"assistant\"\n            and self.exchange.messages[-1].tool_use\n        ):\n            content = []\n            # Append tool results as errors if interrupted.\n            for tool_use in self.exchange.messages[-1].tool_use:\n                content.append(\n                    ToolResult(\n                        tool_use_id=tool_use.id,\n                        output=\"Interrupted by the user to make a correction\",\n                        is_error=True,\n                    )\n                )\n            message = Message(role=\"user\", content=content)\n            self.exchange.add(message)\n            committed.append(message)\n            recovery = f\"We interrupted the existing call to {tool_use.name}. How would you like to proceed?\"\n            message = Message.assistant(recovery)\n            self.exchange.add(message)\n            committed.append(message)\n        # Print the recovery message with markup for visibility.\n        print(f\"[yellow]{recovery}[/]\")\n\n    @property\n    def session_file_path(self) -&gt; Path:\n        return session_path(self.name)\n\n    def load_session(self) -&gt; list[Message]:\n        return read_or_create_file(self.session_file_path)\n\n    def _log_cost(self, start_time: datetime, end_time: datetime) -&gt; None:\n        get_logger().info(get_total_cost_message(self.exchange.get_token_usage(), self.name, start_time, end_time))\n        print(f\"[dim]you can view the cost and token usage in the log directory {LOG_PATH}[/]\")\n\n    def _prompt_overwrite_session(self) -&gt; None:\n        print(f\"[yellow]Session already exists at {self.session_file_path}.[/]\")\n\n        choice = OverwriteSessionPrompt.ask(\"Enter your choice\", show_choices=False)\n        # during __init__ we load the previous context, so we need to\n        # explicitly clear it\n        self.exchange.messages.clear()\n\n        match choice:\n            case \"y\" | \"yes\":\n                print(\"Overwriting existing session\")\n                with open(self.session_file_path, \"w\") as f:\n                    f.write(\"\")\n\n            case \"n\" | \"no\":\n                while True:\n                    new_session_name = Prompt.ask(\"Enter a new session name\")\n                    if not is_existing_session(session_path(new_session_name)):\n                        self.name = new_session_name\n                        break\n                    print(f\"[yellow]Session '{new_session_name}' already exists[/]\")\n\n            case \"r\" | \"resume\":\n                self.exchange.messages.extend(self._get_initial_messages())\n\n    def _remove_empty_session(self) -&gt; bool:\n        \"\"\"\n        Removes the session file only when it's empty.\n\n        Note: This is because a session file is created at the start of the run\n        loop. When a user aborts before their first message empty session files\n        will be created, causing confusion when resuming sessions (which\n        depends on most recent mtime and is non-empty).\n\n        Returns:\n            bool: True if the session file was removed, False otherwise.\n        \"\"\"\n        logger = get_logger()\n        try:\n            if is_empty_session(self.session_file_path):\n                logger.debug(f\"deleting empty session file: {self.session_file_path}\")\n                self.session_file_path.unlink()\n                return True\n        except Exception as e:\n            logger.error(f\"error deleting empty session file: {e}\")\n        return False\n</code></pre>"},{"location":"reference/goose/cli/session.html#goose.cli.session.Session.interrupt_reply","title":"<code>interrupt_reply(committed)</code>","text":"<p>Recover from an interruption at an arbitrary state</p> Source code in <code>src/goose/cli/session.py</code> <pre><code>def interrupt_reply(self, committed: list[Message]) -&gt; None:\n    \"\"\"Recover from an interruption at an arbitrary state\"\"\"\n    # Default recovery message if no user message is pending.\n    recovery = \"We interrupted before the next processing started.\"\n    if self.exchange.messages and self.exchange.messages[-1].role == \"user\":\n        # If the last message is from the user, remove it.\n        self.exchange.messages.pop()\n        committed.pop()\n        recovery = \"We interrupted before the model replied and removed the last message.\"\n\n    if (\n        self.exchange.messages\n        and self.exchange.messages[-1].role == \"assistant\"\n        and self.exchange.messages[-1].tool_use\n    ):\n        content = []\n        # Append tool results as errors if interrupted.\n        for tool_use in self.exchange.messages[-1].tool_use:\n            content.append(\n                ToolResult(\n                    tool_use_id=tool_use.id,\n                    output=\"Interrupted by the user to make a correction\",\n                    is_error=True,\n                )\n            )\n        message = Message(role=\"user\", content=content)\n        self.exchange.add(message)\n        committed.append(message)\n        recovery = f\"We interrupted the existing call to {tool_use.name}. How would you like to proceed?\"\n        message = Message.assistant(recovery)\n        self.exchange.add(message)\n        committed.append(message)\n    # Print the recovery message with markup for visibility.\n    print(f\"[yellow]{recovery}[/]\")\n</code></pre>"},{"location":"reference/goose/cli/session.html#goose.cli.session.Session.reply","title":"<code>reply()</code>","text":"<p>Reply to the last user message, calling tools as needed</p> Source code in <code>src/goose/cli/session.py</code> <pre><code>@observe_wrapper(session_id=lambda instance: instance.name)\ndef reply(self) -&gt; None:\n    \"\"\"Reply to the last user message, calling tools as needed\"\"\"\n    # These are the *raw* messages, before the moderator rewrites things\n    committed = [self.exchange.messages[-1]]\n\n    try:\n        self.status_indicator.update(\"processing request\")\n        response = self.exchange.generate()\n        self.status_indicator.update(\"got response, processing\")\n        committed.append(response)\n\n        if response.text:\n            print(Markdown(response.text))\n\n        while response.tool_use:\n            content = []\n            for tool_use in response.tool_use:\n                tool_result = self.exchange.call_function(tool_use)\n                content.append(tool_result)\n            message = Message(role=\"user\", content=content)\n            committed.append(message)\n            self.exchange.add(message)\n            self.status_indicator.update(\"processing tool results\")\n            response = self.exchange.generate()\n            committed.append(response)\n\n            if response.text:\n                print(Markdown(response.text))\n    except KeyboardInterrupt:\n        # The interrupt reply modifies the message history,\n        # and we sync those changes to committed\n        self.interrupt_reply(committed)\n\n    # we log the committed messages only once the reply completes\n    # this prevents messages related to uncaught errors from being recorded\n    log_messages(self.session_file_path, committed)\n</code></pre>"},{"location":"reference/goose/cli/session.html#goose.cli.session.Session.run","title":"<code>run(new_session=True)</code>","text":"<p>Runs the main loop to handle user inputs and responses. Continues until an empty string is returned from the prompt.</p> <p>Parameters:</p> Name Type Description Default <code>new_session</code> <code>bool</code> <p>True when starting a new session, False when resuming.</p> <code>True</code> Source code in <code>src/goose/cli/session.py</code> <pre><code>def run(self, new_session: bool = True) -&gt; None:\n    \"\"\"\n    Runs the main loop to handle user inputs and responses.\n    Continues until an empty string is returned from the prompt.\n\n    Args:\n        new_session (bool): True when starting a new session, False when resuming.\n    \"\"\"\n    time_start = datetime.now()\n    if is_existing_session(self.session_file_path) and new_session:\n        self._prompt_overwrite_session()\n\n    profile_name = self.profile_name or \"default\"\n    print(f\"[dim]starting session | name: [cyan]{self.name}[/cyan]  profile: [cyan]{profile_name}[/cyan][/dim]\")\n    print()\n    message = self.process_first_message()\n    while message:  # Loop until no input (empty string).\n        self.notifier.start()\n        try:\n            self.exchange.add(message)\n            self.reply()  # Process the user message.\n        except Exception:\n            # rewind to right before the last user message\n            self.exchange.rewind()\n            print(traceback.format_exc())\n            print(\n                \"\\n[red]The error above was an exception we were not able to handle.\\n\\n[/]\"\n                + \"These errors are often related to connection or authentication\\n\"\n                + \"We've removed the conversation up to the most recent user message\"\n                + \" - [yellow]depending on the error you may be able to continue[/]\"\n            )\n        self.notifier.stop()\n        print()  # Print a newline for separation.\n        user_input = self.prompt_session.get_user_input()\n        message = Message.user(text=user_input.text) if user_input.to_continue() else None\n\n    self._remove_empty_session()\n    time_end = datetime.now()\n    self._log_cost(start_time=time_start, end_time=time_end)\n</code></pre>"},{"location":"reference/goose/cli/session.html#goose.cli.session.Session.single_pass","title":"<code>single_pass(initial_message)</code>","text":"<p>Handles a single input message and processes a reply without entering a loop for additional inputs.</p> <p>Parameters:</p> Name Type Description Default <code>initial_message</code> <code>Optional[str]</code> <p>The initial user message to process.</p> required Source code in <code>src/goose/cli/session.py</code> <pre><code>def single_pass(self, initial_message: Optional[str]) -&gt; None:\n    \"\"\"\n    Handles a single input message and processes a reply\n    without entering a loop for additional inputs.\n\n    Args:\n        initial_message (Optional[str]): The initial user message to process.\n    \"\"\"\n    profile = self.profile_name or \"default\"\n    print(f\"[dim]starting session | name: [cyan]{self.name}[/]  profile: [cyan]{profile}[/]\")\n    print(f\"[dim]saving to {self.session_file_path}\")\n\n    # Check to see if there is a planned operation to perform prior to the bespoke prompt\n    if self.has_plan and len(self.exchange.messages) &gt; 0:\n        # Process the plan prompt\n        self.exchange.add(self.exchange.messages.pop())\n        self.reply()\n\n    if initial_message:\n        # Process initial message\n        message = Message.user(initial_message)\n\n        self.exchange.add(message)\n        self.reply()  # Process the user message\n\n    print(f\"[dim]ended run | name: [cyan]{self.name}[/]  profile: [cyan]{profile}[/]\")\n    print(f\"[dim]to resume: [magenta]goose session resume {self.name} --profile {profile}[/][/]\")\n</code></pre>"},{"location":"reference/goose/cli/prompt/index.html","title":"Index","text":""},{"location":"reference/goose/cli/prompt/completer.html","title":"Completer","text":""},{"location":"reference/goose/cli/prompt/create.html","title":"Create","text":""},{"location":"reference/goose/cli/prompt/create.html#goose.cli.prompt.create.create_prompt","title":"<code>create_prompt(commands)</code>","text":"<p>Create a prompt session with the given commands.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>dict[str, Command]</code> <p>A dictionary of command names, and instances of Command classes.</p> required Source code in <code>src/goose/cli/prompt/create.py</code> <pre><code>def create_prompt(commands: dict[str, Command]) -&gt; PromptSession:\n    \"\"\"\n    Create a prompt session with the given commands.\n\n    Args:\n        commands (dict[str, Command]): A dictionary of command names, and instances of Command classes.\n    \"\"\"\n    # Define custom style\n    style = Style.from_dict(\n        {\n            \"parameter\": \"bold\",\n            \"command\": \"ansiblue bold\",\n            \"text\": \"default\",\n        }\n    )\n\n    bindings = KeyBindings()\n\n    # Bind the \"Option + Enter\" key to insert a newline\n    @bindings.add(Keys.Escape, Keys.ControlM)\n    def _(event: KeyPressEvent) -&gt; None:\n        buffer = event.app.current_buffer\n        buffer.insert_text(\"\\n\")\n\n    # Bind the \"Enter\" key to accept the completion if the completion menu is open\n    # otherwise just submit the input\n    @bindings.add(Keys.Enter)\n    def _(event: KeyPressEvent) -&gt; None:\n        buffer = event.current_buffer\n        app = get_app()\n\n        if app.layout.has_focus(buffer):\n            # Check if the completion menu is open\n            if buffer.complete_state:\n                # accept completion\n                buffer.complete_state = None\n            else:\n                buffer.validate_and_handle()\n\n    @bindings.add(Keys.ControlY)\n    def _(event: KeyPressEvent) -&gt; None:\n        buffer = event.app.current_buffer\n        app = get_app()\n        if app.layout.has_focus(buffer):\n            # Check if the completion menu is open\n            if buffer.complete_state:\n                # accept completion\n                buffer.complete_state = None\n\n    return PromptSession(\n        completer=GoosePromptCompleter(commands=commands),\n        lexer=PromptLexer(list(commands.keys())),\n        style=style,\n        key_bindings=bindings,\n    )\n</code></pre>"},{"location":"reference/goose/cli/prompt/goose_prompt_session.html","title":"Goose prompt session","text":""},{"location":"reference/goose/cli/prompt/lexer.html","title":"Lexer","text":""},{"location":"reference/goose/cli/prompt/prompt_validator.html","title":"Prompt validator","text":""},{"location":"reference/goose/cli/prompt/user_input.html","title":"User input","text":""},{"location":"reference/goose/command/index.html","title":"Index","text":""},{"location":"reference/goose/command/base.html","title":"Base","text":""},{"location":"reference/goose/command/base.html#goose.command.base.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A command that can be executed by the CLI.</p> Source code in <code>src/goose/command/base.py</code> <pre><code>class Command(ABC):\n    \"\"\"A command that can be executed by the CLI.\"\"\"\n\n    def get_completions(self, query: str) -&gt; list[Completion]:\n        \"\"\"\n        Get completions for the command.\n\n        Args:\n            query (str): The current query.\n        \"\"\"\n        return []\n\n    def execute(self, query: str) -&gt; Optional[str]:\n        \"\"\"\n        Execute's the command and replaces it with the output.\n\n        Args:\n            query (str): The query to execute.\n        \"\"\"\n        return \"\"\n</code></pre>"},{"location":"reference/goose/command/base.html#goose.command.base.Command.execute","title":"<code>execute(query)</code>","text":"<p>Execute's the command and replaces it with the output.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to execute.</p> required Source code in <code>src/goose/command/base.py</code> <pre><code>def execute(self, query: str) -&gt; Optional[str]:\n    \"\"\"\n    Execute's the command and replaces it with the output.\n\n    Args:\n        query (str): The query to execute.\n    \"\"\"\n    return \"\"\n</code></pre>"},{"location":"reference/goose/command/base.html#goose.command.base.Command.get_completions","title":"<code>get_completions(query)</code>","text":"<p>Get completions for the command.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The current query.</p> required Source code in <code>src/goose/command/base.py</code> <pre><code>def get_completions(self, query: str) -&gt; list[Completion]:\n    \"\"\"\n    Get completions for the command.\n\n    Args:\n        query (str): The current query.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/goose/command/file.html","title":"File","text":""},{"location":"reference/goose/toolkit/index.html","title":"Index","text":""},{"location":"reference/goose/toolkit/base.html","title":"Base","text":""},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Requirements","title":"<code>Requirements</code>","text":"<p>A collection of requirements for advanced toolkits</p> <p>Requirements are an advanced use case, most toolkits will not need to use these. They allow one toolkit to interact with another's state.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>@define\nclass Requirements:\n    \"\"\"A collection of requirements for advanced toolkits\n\n    Requirements are an advanced use case, most toolkits will not need to\n    use these. They allow one toolkit to interact with another's state.\n    \"\"\"\n\n    _toolkit: str\n    _requirements: Mapping[str, \"Toolkit\"] = field(factory=dict)\n\n    def get(self, requirement: str) -&gt; \"Toolkit\":\n        \"\"\"Get a requirement by name.\"\"\"\n        if requirement not in self._requirements:\n            raise RuntimeError(\n                f\"The toolkit '{self._toolkit}' requested a requirement '{requirement}' but none was passed!\\n\"\n                + f\"  Make sure to include `requires: {{{requirement}: ...}}` in your profile config\\n\"\n                + f\"  See the documentation for {self._toolkit} for more details\"\n            )\n        return self._requirements[requirement]\n</code></pre>"},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Requirements.get","title":"<code>get(requirement)</code>","text":"<p>Get a requirement by name.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>def get(self, requirement: str) -&gt; \"Toolkit\":\n    \"\"\"Get a requirement by name.\"\"\"\n    if requirement not in self._requirements:\n        raise RuntimeError(\n            f\"The toolkit '{self._toolkit}' requested a requirement '{requirement}' but none was passed!\\n\"\n            + f\"  Make sure to include `requires: {{{requirement}: ...}}` in your profile config\\n\"\n            + f\"  See the documentation for {self._toolkit} for more details\"\n        )\n    return self._requirements[requirement]\n</code></pre>"},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Toolkit","title":"<code>Toolkit</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A collection of tools with corresponding prompting</p> <p>This class defines the interface that all toolkit implementations must follow, providing a system prompt and a collection of tools. Both are allowed to be empty if they are not required for the toolkit.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>class Toolkit(ABC):\n    \"\"\"A collection of tools with corresponding prompting\n\n    This class defines the interface that all toolkit implementations must follow,\n    providing a system prompt and a collection of tools. Both are allowed to be\n    empty if they are not required for the toolkit.\n    \"\"\"\n\n    def __init__(self, notifier: Notifier, requires: Optional[Requirements] = None) -&gt; None:\n        self.notifier = notifier\n        # This needs to be updated after the fact via build_exchange\n        self.exchange_view = None\n\n    def system(self) -&gt; str:\n        \"\"\"Get the addition to the system prompt for this toolkit.\"\"\"\n        return \"\"\n\n    def tools(self) -&gt; tuple[Tool, ...]:\n        \"\"\"Get the tools for this toolkit\n\n        This default method looks for functions on the toolkit annotated\n        with @tool.\n        \"\"\"\n        candidates = inspect.getmembers(self, predicate=inspect.ismethod)\n        return (Tool.from_function(candidate) for _, candidate in candidates if getattr(candidate, \"_is_tool\", None))\n</code></pre>"},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Toolkit.system","title":"<code>system()</code>","text":"<p>Get the addition to the system prompt for this toolkit.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>def system(self) -&gt; str:\n    \"\"\"Get the addition to the system prompt for this toolkit.\"\"\"\n    return \"\"\n</code></pre>"},{"location":"reference/goose/toolkit/base.html#goose.toolkit.base.Toolkit.tools","title":"<code>tools()</code>","text":"<p>Get the tools for this toolkit</p> <p>This default method looks for functions on the toolkit annotated with @tool.</p> Source code in <code>src/goose/toolkit/base.py</code> <pre><code>def tools(self) -&gt; tuple[Tool, ...]:\n    \"\"\"Get the tools for this toolkit\n\n    This default method looks for functions on the toolkit annotated\n    with @tool.\n    \"\"\"\n    candidates = inspect.getmembers(self, predicate=inspect.ismethod)\n    return (Tool.from_function(candidate) for _, candidate in candidates if getattr(candidate, \"_is_tool\", None))\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html","title":"Developer","text":""},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer","title":"<code>Developer</code>","text":"<p>               Bases: <code>Toolkit</code></p> <p>Provides a set of general purpose development capabilities</p> <p>The tools include plan management, a general purpose shell execution tool, and file operations. We also include some default shell strategies in the prompt, such as using ripgrep</p> Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>class Developer(Toolkit):\n    \"\"\"Provides a set of general purpose development capabilities\n\n    The tools include plan management, a general purpose shell execution tool, and file operations.\n    We also include some default shell strategies in the prompt, such as using ripgrep\n    \"\"\"\n\n    def __init__(self, *args: object, **kwargs: dict[str, object]) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self.timestamps: dict[str, float] = {}\n        self.cwd = os.getcwd()\n\n    def system(self) -&gt; str:\n        \"\"\"Retrieve system configuration details for developer\"\"\"\n        system_prompt = Message.load(\"prompts/developer.jinja\").text\n        hints = fetch_goosehints()\n\n        if hints:\n            system_prompt = f\"{system_prompt}\\n\\nHints:\\n{hints}\"\n        return system_prompt\n\n    @tool\n    def update_plan(self, tasks: list[dict]) -&gt; list[dict]:\n        \"\"\"\n        Update the plan by overwriting all current tasks\n\n        This can be used to update the status of a task. This update will be\n        shown to the user directly, you do not need to reiterate it\n\n        Args:\n            tasks (list(dict)): The list of tasks, where each task is a dictionary\n                with a key for the task \"description\" and the task \"status\". The status\n                MUST be one of \"planned\", \"complete\", \"failed\", \"in-progress\".\n\n        \"\"\"\n        # Validate the status of each task to ensure it is one of the accepted values.\n        for task in tasks:\n            if task[\"status\"] not in {\"planned\", \"complete\", \"failed\", \"in-progress\"}:\n                raise ValueError(f\"Invalid task status: {task['status']}\")\n\n        # Create a table with columns for the index, description, and status of each task.\n        table = Table(expand=True)\n        table.add_column(\"#\", justify=\"right\", style=\"magenta\")\n        table.add_column(\"Task\", justify=\"left\")\n        table.add_column(\"Status\", justify=\"left\")\n\n        # Mapping of statuses to emojis for better visual representation in the table.\n        emoji = {\"planned\": \"\u23f3\", \"complete\": \"\u2705\", \"failed\": \"\u274c\", \"in-progress\": \"\ud83d\udd51\"}\n        for i, entry in enumerate(tasks):\n            table.add_row(str(i), entry[\"description\"], emoji[entry[\"status\"]])\n\n        # Log the table to display it directly to the user\n        # `.log` method is used here to log the command execution in the application's UX\n        self.notifier.log(table)\n\n        # Return the tasks unchanged as the function's primary purpose is to update and display the task status.\n        return tasks\n\n    @tool\n    def fetch_web_content(self, url: str) -&gt; str:\n        \"\"\"\n        Fetch content from a URL using httpx.\n\n        Args:\n            url (str): url of the site to visit.\n        Returns:\n            (dict): A dictionary with two keys:\n                - 'html_file_path' (str): Path to a html file which has the content of the page. It will be very large so use rg to search it or head in chunks. Will contain meta data and links and markup.\n                - 'text_file_path' (str): Path to a plain text file which has the some of the content of the page. It will be large so use rg to search it or head in chunks. If content isn't there, try the html variant.\n        \"\"\"  # noqa\n        friendly_name = re.sub(r\"[^a-zA-Z0-9]\", \"_\", url)[:50]  # Limit length to prevent filenames from being too long\n\n        try:\n            result = httpx.get(url, follow_redirects=True).text\n            with tempfile.NamedTemporaryFile(delete=False, mode=\"w\", suffix=f\"_{friendly_name}.html\") as tmp_file:\n                tmp_file.write(result)\n                tmp_text_file_path = tmp_file.name.replace(\".html\", \".txt\")\n                plain_text = re.sub(\n                    r\"&lt;head.*?&gt;.*?&lt;/head&gt;|&lt;script.*?&gt;.*?&lt;/script&gt;|&lt;style.*?&gt;.*?&lt;/style&gt;|&lt;[^&gt;]+&gt;\",\n                    \"\",\n                    result,\n                    flags=re.DOTALL,\n                )  # Remove head, script, and style tags/content, then any other tags\n                with open(tmp_text_file_path, \"w\") as text_file:\n                    text_file.write(plain_text)\n                return {\"html_file_path\": tmp_file.name, \"text_file_path\": tmp_text_file_path}\n        except httpx.HTTPStatusError as exc:\n            self.notifier.log(f\"Failed fetching with HTTP error: {exc.response.status_code}\")\n        except Exception as exc:\n            self.notifier.log(f\"Failed fetching with error: {str(exc)}\")\n\n    @tool\n    def patch_file(self, path: str, before: str, after: str) -&gt; str:\n        \"\"\"Patch the file at the specified by replacing before with after\n\n        Before **must** be present exactly once in the file, so that it can safely\n        be replaced with after.\n\n        Args:\n            path (str): The path to the file, in the format \"path/to/file.txt\"\n            before (str): The content that will be replaced\n            after (str): The content it will be replaced with\n        \"\"\"\n        self.notifier.status(f\"editing {path}\")\n        _path = Path(path)\n        language = get_language(path)\n\n        content = _path.read_text()\n\n        if content.count(before) &gt; 1:\n            raise ValueError(\"The before content is present multiple times in the file, be more specific.\")\n        if content.count(before) &lt; 1:\n            raise ValueError(\"The before content was not found in file, be careful that you recreate it exactly.\")\n\n        content = content.replace(before, after)\n        _path.write_text(content)\n\n        output = f\"\"\"\n```{language}\n{before}\n```\n-&gt;\n```{language}\n{after}\n```\n\"\"\"\n        self.notifier.log(Rule(RULEPREFIX + path, style=RULESTYLE, align=\"left\"))\n        self.notifier.log(Markdown(output))\n        return \"Succesfully replaced before with after.\"\n\n    @tool\n    def read_file(self, path: str) -&gt; str:\n        \"\"\"Read the content of the file at path\n\n        Args:\n            path (str): The destination file path, in the format \"path/to/file.txt\"\n        \"\"\"\n        language = get_language(path)\n        content = Path(path).expanduser().read_text()\n        self.notifier.log(Markdown(f\"```\\ncat {path}\\n```\"))\n        # Record the last read timestamp\n        self.timestamps[path] = os.path.getmtime(path)\n        return f\"```{language}\\n{content}\\n```\"\n\n    @tool\n    def shell(self, command: str) -&gt; str:\n        \"\"\"\n        Execute a command on the shell\n\n        This will return the output and error concatenated into a single string, as\n        you would see from running on the command line. There will also be an indication\n        of if the command succeeded or failed.\n\n        Args:\n            command (str): The shell command to run. It can support multiline statements\n                if you need to run more than one at a time\n        \"\"\"\n        # Log the command being executed in a visually structured format (Markdown).\n        self.notifier.log(Rule(RULEPREFIX + \"shell\", style=RULESTYLE, align=\"left\"))\n        self.notifier.log(Markdown(f\"```bash\\n{command}\\n```\"))\n        return shell(command, self.notifier, self.exchange_view)\n\n    @tool\n    def write_file(self, path: str, content: str) -&gt; str:\n        \"\"\"\n        Write a file at the specified path with the provided content. This will create any directories if they do not exist.\n        The content will fully overwrite the existing file.\n\n        Args:\n            path (str): The destination file path, in the format \"path/to/file.txt\"\n            content (str): The raw file content.\n        \"\"\"  # noqa: E501\n        self.notifier.status(\"writing file\")\n        # Get the programming language for syntax highlighting in logs\n        language = get_language(path)\n        md = f\"```{language}\\n{content}\\n```\"\n\n        # Log the content that will be written to the file\n        # .log` method is used here to log the command execution in the application's UX\n        # this method is dynamically attached to functions in the Goose framework\n        self.notifier.log(Rule(RULEPREFIX + path, style=RULESTYLE, align=\"left\"))\n        self.notifier.log(Markdown(md))\n\n        _path = Path(path)\n        if path in self.timestamps:\n            last_read_timestamp = self.timestamps.get(path, 0.0)\n            current_timestamp = os.path.getmtime(path)\n            if current_timestamp &gt; last_read_timestamp:\n                raise RuntimeError(\n                    f\"File '{path}' has been modified since it was last read.\"\n                    + \" Read the file to incorporate changes or update your plan.\"\n                )\n\n        # Prepare the path and create any necessary parent directories\n        _path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Write the content to the file\n        _path.write_text(content)\n\n        # Update the last read timestamp after writing to the file\n        self.timestamps[path] = os.path.getmtime(path)\n\n        # Return a success message\n        return f\"Successfully wrote to {path}\"\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.fetch_web_content","title":"<code>fetch_web_content(url)</code>","text":"<p>Fetch content from a URL using httpx.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>url of the site to visit.</p> required <p>Returns:     (dict): A dictionary with two keys:         - 'html_file_path' (str): Path to a html file which has the content of the page. It will be very large so use rg to search it or head in chunks. Will contain meta data and links and markup.         - 'text_file_path' (str): Path to a plain text file which has the some of the content of the page. It will be large so use rg to search it or head in chunks. If content isn't there, try the html variant.</p> Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>@tool\ndef fetch_web_content(self, url: str) -&gt; str:\n    \"\"\"\n    Fetch content from a URL using httpx.\n\n    Args:\n        url (str): url of the site to visit.\n    Returns:\n        (dict): A dictionary with two keys:\n            - 'html_file_path' (str): Path to a html file which has the content of the page. It will be very large so use rg to search it or head in chunks. Will contain meta data and links and markup.\n            - 'text_file_path' (str): Path to a plain text file which has the some of the content of the page. It will be large so use rg to search it or head in chunks. If content isn't there, try the html variant.\n    \"\"\"  # noqa\n    friendly_name = re.sub(r\"[^a-zA-Z0-9]\", \"_\", url)[:50]  # Limit length to prevent filenames from being too long\n\n    try:\n        result = httpx.get(url, follow_redirects=True).text\n        with tempfile.NamedTemporaryFile(delete=False, mode=\"w\", suffix=f\"_{friendly_name}.html\") as tmp_file:\n            tmp_file.write(result)\n            tmp_text_file_path = tmp_file.name.replace(\".html\", \".txt\")\n            plain_text = re.sub(\n                r\"&lt;head.*?&gt;.*?&lt;/head&gt;|&lt;script.*?&gt;.*?&lt;/script&gt;|&lt;style.*?&gt;.*?&lt;/style&gt;|&lt;[^&gt;]+&gt;\",\n                \"\",\n                result,\n                flags=re.DOTALL,\n            )  # Remove head, script, and style tags/content, then any other tags\n            with open(tmp_text_file_path, \"w\") as text_file:\n                text_file.write(plain_text)\n            return {\"html_file_path\": tmp_file.name, \"text_file_path\": tmp_text_file_path}\n    except httpx.HTTPStatusError as exc:\n        self.notifier.log(f\"Failed fetching with HTTP error: {exc.response.status_code}\")\n    except Exception as exc:\n        self.notifier.log(f\"Failed fetching with error: {str(exc)}\")\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.patch_file","title":"<code>patch_file(path, before, after)</code>","text":"<p>Patch the file at the specified by replacing before with after</p> <p>Before must be present exactly once in the file, so that it can safely be replaced with after.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file, in the format \"path/to/file.txt\"</p> required <code>before</code> <code>str</code> <p>The content that will be replaced</p> required <code>after</code> <code>str</code> <p>The content it will be replaced with</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>    @tool\n    def patch_file(self, path: str, before: str, after: str) -&gt; str:\n        \"\"\"Patch the file at the specified by replacing before with after\n\n        Before **must** be present exactly once in the file, so that it can safely\n        be replaced with after.\n\n        Args:\n            path (str): The path to the file, in the format \"path/to/file.txt\"\n            before (str): The content that will be replaced\n            after (str): The content it will be replaced with\n        \"\"\"\n        self.notifier.status(f\"editing {path}\")\n        _path = Path(path)\n        language = get_language(path)\n\n        content = _path.read_text()\n\n        if content.count(before) &gt; 1:\n            raise ValueError(\"The before content is present multiple times in the file, be more specific.\")\n        if content.count(before) &lt; 1:\n            raise ValueError(\"The before content was not found in file, be careful that you recreate it exactly.\")\n\n        content = content.replace(before, after)\n        _path.write_text(content)\n\n        output = f\"\"\"\n```{language}\n{before}\n```\n-&gt;\n```{language}\n{after}\n```\n\"\"\"\n        self.notifier.log(Rule(RULEPREFIX + path, style=RULESTYLE, align=\"left\"))\n        self.notifier.log(Markdown(output))\n        return \"Succesfully replaced before with after.\"\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.read_file","title":"<code>read_file(path)</code>","text":"<p>Read the content of the file at path</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The destination file path, in the format \"path/to/file.txt\"</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>@tool\ndef read_file(self, path: str) -&gt; str:\n    \"\"\"Read the content of the file at path\n\n    Args:\n        path (str): The destination file path, in the format \"path/to/file.txt\"\n    \"\"\"\n    language = get_language(path)\n    content = Path(path).expanduser().read_text()\n    self.notifier.log(Markdown(f\"```\\ncat {path}\\n```\"))\n    # Record the last read timestamp\n    self.timestamps[path] = os.path.getmtime(path)\n    return f\"```{language}\\n{content}\\n```\"\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.shell","title":"<code>shell(command)</code>","text":"<p>Execute a command on the shell</p> <p>This will return the output and error concatenated into a single string, as you would see from running on the command line. There will also be an indication of if the command succeeded or failed.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The shell command to run. It can support multiline statements if you need to run more than one at a time</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>@tool\ndef shell(self, command: str) -&gt; str:\n    \"\"\"\n    Execute a command on the shell\n\n    This will return the output and error concatenated into a single string, as\n    you would see from running on the command line. There will also be an indication\n    of if the command succeeded or failed.\n\n    Args:\n        command (str): The shell command to run. It can support multiline statements\n            if you need to run more than one at a time\n    \"\"\"\n    # Log the command being executed in a visually structured format (Markdown).\n    self.notifier.log(Rule(RULEPREFIX + \"shell\", style=RULESTYLE, align=\"left\"))\n    self.notifier.log(Markdown(f\"```bash\\n{command}\\n```\"))\n    return shell(command, self.notifier, self.exchange_view)\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.system","title":"<code>system()</code>","text":"<p>Retrieve system configuration details for developer</p> Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>def system(self) -&gt; str:\n    \"\"\"Retrieve system configuration details for developer\"\"\"\n    system_prompt = Message.load(\"prompts/developer.jinja\").text\n    hints = fetch_goosehints()\n\n    if hints:\n        system_prompt = f\"{system_prompt}\\n\\nHints:\\n{hints}\"\n    return system_prompt\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.update_plan","title":"<code>update_plan(tasks)</code>","text":"<p>Update the plan by overwriting all current tasks</p> <p>This can be used to update the status of a task. This update will be shown to the user directly, you do not need to reiterate it</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list(dict</code> <p>The list of tasks, where each task is a dictionary with a key for the task \"description\" and the task \"status\". The status MUST be one of \"planned\", \"complete\", \"failed\", \"in-progress\".</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>@tool\ndef update_plan(self, tasks: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Update the plan by overwriting all current tasks\n\n    This can be used to update the status of a task. This update will be\n    shown to the user directly, you do not need to reiterate it\n\n    Args:\n        tasks (list(dict)): The list of tasks, where each task is a dictionary\n            with a key for the task \"description\" and the task \"status\". The status\n            MUST be one of \"planned\", \"complete\", \"failed\", \"in-progress\".\n\n    \"\"\"\n    # Validate the status of each task to ensure it is one of the accepted values.\n    for task in tasks:\n        if task[\"status\"] not in {\"planned\", \"complete\", \"failed\", \"in-progress\"}:\n            raise ValueError(f\"Invalid task status: {task['status']}\")\n\n    # Create a table with columns for the index, description, and status of each task.\n    table = Table(expand=True)\n    table.add_column(\"#\", justify=\"right\", style=\"magenta\")\n    table.add_column(\"Task\", justify=\"left\")\n    table.add_column(\"Status\", justify=\"left\")\n\n    # Mapping of statuses to emojis for better visual representation in the table.\n    emoji = {\"planned\": \"\u23f3\", \"complete\": \"\u2705\", \"failed\": \"\u274c\", \"in-progress\": \"\ud83d\udd51\"}\n    for i, entry in enumerate(tasks):\n        table.add_row(str(i), entry[\"description\"], emoji[entry[\"status\"]])\n\n    # Log the table to display it directly to the user\n    # `.log` method is used here to log the command execution in the application's UX\n    self.notifier.log(table)\n\n    # Return the tasks unchanged as the function's primary purpose is to update and display the task status.\n    return tasks\n</code></pre>"},{"location":"reference/goose/toolkit/developer.html#goose.toolkit.developer.Developer.write_file","title":"<code>write_file(path, content)</code>","text":"<p>Write a file at the specified path with the provided content. This will create any directories if they do not exist. The content will fully overwrite the existing file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The destination file path, in the format \"path/to/file.txt\"</p> required <code>content</code> <code>str</code> <p>The raw file content.</p> required Source code in <code>src/goose/toolkit/developer.py</code> <pre><code>@tool\ndef write_file(self, path: str, content: str) -&gt; str:\n    \"\"\"\n    Write a file at the specified path with the provided content. This will create any directories if they do not exist.\n    The content will fully overwrite the existing file.\n\n    Args:\n        path (str): The destination file path, in the format \"path/to/file.txt\"\n        content (str): The raw file content.\n    \"\"\"  # noqa: E501\n    self.notifier.status(\"writing file\")\n    # Get the programming language for syntax highlighting in logs\n    language = get_language(path)\n    md = f\"```{language}\\n{content}\\n```\"\n\n    # Log the content that will be written to the file\n    # .log` method is used here to log the command execution in the application's UX\n    # this method is dynamically attached to functions in the Goose framework\n    self.notifier.log(Rule(RULEPREFIX + path, style=RULESTYLE, align=\"left\"))\n    self.notifier.log(Markdown(md))\n\n    _path = Path(path)\n    if path in self.timestamps:\n        last_read_timestamp = self.timestamps.get(path, 0.0)\n        current_timestamp = os.path.getmtime(path)\n        if current_timestamp &gt; last_read_timestamp:\n            raise RuntimeError(\n                f\"File '{path}' has been modified since it was last read.\"\n                + \" Read the file to incorporate changes or update your plan.\"\n            )\n\n    # Prepare the path and create any necessary parent directories\n    _path.parent.mkdir(parents=True, exist_ok=True)\n\n    # Write the content to the file\n    _path.write_text(content)\n\n    # Update the last read timestamp after writing to the file\n    self.timestamps[path] = os.path.getmtime(path)\n\n    # Return a success message\n    return f\"Successfully wrote to {path}\"\n</code></pre>"},{"location":"reference/goose/toolkit/github.html","title":"Github","text":""},{"location":"reference/goose/toolkit/github.html#goose.toolkit.github.Github","title":"<code>Github</code>","text":"<p>               Bases: <code>Toolkit</code></p> <p>Provides an additional prompt on how to interact with Github</p> Source code in <code>src/goose/toolkit/github.py</code> <pre><code>class Github(Toolkit):\n    \"\"\"Provides an additional prompt on how to interact with Github\"\"\"\n\n    def system(self) -&gt; str:\n        \"\"\"Retrieve detailed configuration and procedural guidelines for GitHub operations\"\"\"\n        return Message.load(\"prompts/github.jinja\").text\n</code></pre>"},{"location":"reference/goose/toolkit/github.html#goose.toolkit.github.Github.system","title":"<code>system()</code>","text":"<p>Retrieve detailed configuration and procedural guidelines for GitHub operations</p> Source code in <code>src/goose/toolkit/github.py</code> <pre><code>def system(self) -&gt; str:\n    \"\"\"Retrieve detailed configuration and procedural guidelines for GitHub operations\"\"\"\n    return Message.load(\"prompts/github.jinja\").text\n</code></pre>"},{"location":"reference/goose/toolkit/lint.html","title":"Lint","text":""},{"location":"reference/goose/toolkit/screen.html","title":"Screen","text":""},{"location":"reference/goose/toolkit/screen.html#goose.toolkit.screen.Screen","title":"<code>Screen</code>","text":"<p>               Bases: <code>Toolkit</code></p> <p>Provides an instructions on when and how to work with screenshots</p> Source code in <code>src/goose/toolkit/screen.py</code> <pre><code>class Screen(Toolkit):\n    \"\"\"Provides an instructions on when and how to work with screenshots\"\"\"\n\n    @tool\n    def take_screenshot(self, display: int = 1) -&gt; str:\n        \"\"\"\n        Take a screenshot to assist the user in debugging or designing an app. They may need\n        help with moving a screen element, or interacting in some way where you could do with\n        seeing the screen.\n\n        Args:\n            display (int): Display to take the screen shot in. Default is the main display (1). Must be a value greater than 1.\n        \"\"\"  # noqa: E501\n        # Generate a random tmp filename for screenshot\n        filename = f\"/tmp/goose_screenshot_{uuid.uuid4().hex}.jpg\"\n        screen_capture_command = [\"screencapture\", \"-x\", \"-D\", str(display), filename, \"-f\", \"jpg\"]\n\n        subprocess.run(screen_capture_command, check=True, capture_output=True)\n\n        resize_command = [\"sips\", \"--resampleWidth\", \"768\", filename, \"-s\", \"format\", \"jpeg\"]\n        subprocess.run(resize_command, check=True, capture_output=True)\n\n        self.notifier.log(\n            Panel.fit(\n                Markdown(f\"```bash\\n{' '.join(screen_capture_command)}\"),\n                title=\"screen\",\n            )\n        )\n\n        return f\"image:{filename}\"\n\n    # Provide any system instructions for the model\n    # This can be generated dynamically, and is run at startup time\n    def system(self) -&gt; str:\n        return \"\"\"**When the user wants you to help debug, or work on a visual design by looking at their screen, IDE or browser, call the take_screenshot and send the output from the user.**\"\"\"  # noqa: E501\n</code></pre>"},{"location":"reference/goose/toolkit/screen.html#goose.toolkit.screen.Screen.take_screenshot","title":"<code>take_screenshot(display=1)</code>","text":"<p>Take a screenshot to assist the user in debugging or designing an app. They may need help with moving a screen element, or interacting in some way where you could do with seeing the screen.</p> <p>Parameters:</p> Name Type Description Default <code>display</code> <code>int</code> <p>Display to take the screen shot in. Default is the main display (1). Must be a value greater than 1.</p> <code>1</code> Source code in <code>src/goose/toolkit/screen.py</code> <pre><code>@tool\ndef take_screenshot(self, display: int = 1) -&gt; str:\n    \"\"\"\n    Take a screenshot to assist the user in debugging or designing an app. They may need\n    help with moving a screen element, or interacting in some way where you could do with\n    seeing the screen.\n\n    Args:\n        display (int): Display to take the screen shot in. Default is the main display (1). Must be a value greater than 1.\n    \"\"\"  # noqa: E501\n    # Generate a random tmp filename for screenshot\n    filename = f\"/tmp/goose_screenshot_{uuid.uuid4().hex}.jpg\"\n    screen_capture_command = [\"screencapture\", \"-x\", \"-D\", str(display), filename, \"-f\", \"jpg\"]\n\n    subprocess.run(screen_capture_command, check=True, capture_output=True)\n\n    resize_command = [\"sips\", \"--resampleWidth\", \"768\", filename, \"-s\", \"format\", \"jpeg\"]\n    subprocess.run(resize_command, check=True, capture_output=True)\n\n    self.notifier.log(\n        Panel.fit(\n            Markdown(f\"```bash\\n{' '.join(screen_capture_command)}\"),\n            title=\"screen\",\n        )\n    )\n\n    return f\"image:{filename}\"\n</code></pre>"},{"location":"reference/goose/toolkit/utils.html","title":"Utils","text":""},{"location":"reference/goose/toolkit/utils.html#goose.toolkit.utils.get_language","title":"<code>get_language(filename)</code>","text":"<p>Determine the programming language of a file based on its filename extension.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file for which to determine the programming language.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the programming language if recognized, otherwise an empty string.</p> Source code in <code>src/goose/toolkit/utils.py</code> <pre><code>def get_language(filename: str) -&gt; str:\n    \"\"\"\n    Determine the programming language of a file based on its filename extension.\n\n    Args:\n        filename (str): The name of the file for which to determine the programming language.\n\n    Returns:\n        str: The name of the programming language if recognized, otherwise an empty string.\n    \"\"\"\n    try:\n        lexer = get_lexer_for_filename(filename)\n        return lexer.name.lower()\n    except ClassNotFound:\n        return \"\"\n</code></pre>"},{"location":"reference/goose/toolkit/utils.html#goose.toolkit.utils.render_template","title":"<code>render_template(template_path, context=None)</code>","text":"<p>Renders a Jinja2 template given a Pathlib path, with no context needed.</p> <p>:param template_path: Path to the Jinja2 template file. :param context: Optional dictionary containing the context for rendering the template. :return: Rendered template as a string.</p> Source code in <code>src/goose/toolkit/utils.py</code> <pre><code>def render_template(template_path: Path, context: Optional[dict] = None) -&gt; str:\n    \"\"\"\n    Renders a Jinja2 template given a Pathlib path, with no context needed.\n\n    :param template_path: Path to the Jinja2 template file.\n    :param context: Optional dictionary containing the context for rendering the template.\n    :return: Rendered template as a string.\n    \"\"\"\n    # Ensure the path is absolute and exists\n    if not template_path.is_absolute():\n        template_path = template_path.resolve()\n\n    if not template_path.exists():\n        raise FileNotFoundError(f\"Template file {template_path} does not exist.\")\n\n    env = Environment(loader=FileSystemLoader(template_path.parent))\n    template = env.get_template(template_path.name)\n    return template.render(context or {})\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/index.html","title":"Index","text":""},{"location":"reference/goose/toolkit/repo_context/repo_context.html","title":"Repo context","text":""},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext","title":"<code>RepoContext</code>","text":"<p>               Bases: <code>Toolkit</code></p> <p>Provides context about the current repository</p> Source code in <code>src/goose/toolkit/repo_context/repo_context.py</code> <pre><code>class RepoContext(Toolkit):\n    \"\"\"Provides context about the current repository\"\"\"\n\n    def __init__(self, notifier: Notifier, requires: Requirements) -&gt; None:\n        super().__init__(notifier=notifier, requires=requires)\n\n        self.repo_project_root, self.is_git_repo, self.goose_session_root = self.determine_git_proj()\n\n    def determine_git_proj(self) -&gt; tuple[str, bool, str]:\n        \"\"\"Determines the root as well as where Goose is currently running\n\n        If the project is not part of a Github repo, the root of the project will be defined as the current working\n        directory\n\n        Returns:\n            str: path to the root of the project (if part of a local repository) or the CWD if not\n            boolean: if Goose is operating within local repository or not\n            str: path to where the Goose session is running (the CWD)\n        \"\"\"\n        # FIXME: monorepos\n        cwd = os.getcwd()\n        command = \"git rev-parse --show-toplevel\"\n        result: CompletedProcess = run(command, shell=True, text=True, capture_output=True, check=False)\n        if result.returncode == 0:\n            project_root = result.stdout.strip()\n            return project_root, True, cwd\n        else:\n            self.notifier.log(\"Not part of a Git repository. Returning current working directory\")\n            return cwd, False, cwd\n\n    @property\n    @cache\n    def repo_size(self) -&gt; float:\n        \"\"\"Returns the size of the repo in MB (if Goose detects its running in a local repository\n\n        This measurement can be used to guess if the local repository is a monorepo\n\n        Returns:\n            float: size of project in MB\n        \"\"\"\n        # in MB\n        if self.is_git_repo:\n            return get_repo_size(self.repo_project_root)\n        else:\n            self.notifier.log(\"Not a git repo. Returning 0.\")\n            return 0.0\n\n    @property\n    def is_mono_repo(self) -&gt; bool:\n        \"\"\"An boolean indicator of whether the local repository is part of a monorepo\n\n        Returns:\n            boolean: True if above 2000 MB; False otherwise\n        \"\"\"\n        # java: 6394.367112159729\n        # go: 3729.93 MB\n        return self.repo_size &gt; 2000\n\n    @tool\n    def summarize_current_project(self) -&gt; dict[str, str]:\n        \"\"\"Summarizes the current project based on repo root (if git repo) or current project_directory (if not)\n\n        Returns:\n            summary (dict[str, str]): Keys are file paths and values are the summaries\n        \"\"\"\n\n        self.notifier.log(\"Summarizing the most relevant files in the current project. This may take a while...\")\n\n        if self.is_mono_repo:\n            self.notifier.log(\"This might be a monorepo. Goose performs better on smaller projects. Using CWD.\")\n            # TODO: prompt user to specify a subdirectory\n            project_directory = self.goose_session_root\n        else:\n            project_directory = self.repo_project_root\n\n        # before selecting files and summarizing look for summarization file\n        project_name = project_directory.split(\"/\")[-1]\n        summary = load_summary_file_if_exists(project_name=project_name)\n        if summary:\n            self.notifier.log(\"Summary file for project exists already -- loading into the context\")\n            return summary\n\n        # clear exchange and replace the system prompt with instructions on why and how to select files to summarize\n        file_select_exchange = clear_exchange(self.exchange_view.accelerator, clear_tools=True)\n        system = Message.load(\"prompts/repo_context.jinja\").text\n        file_select_exchange = replace_prompt(exchange=file_select_exchange, prompt=system)\n        files = goose_picks_files(root=project_directory, exchange=file_select_exchange)\n\n        # summarize the selected files using a blank exchange with no tools\n        summary = summarize_files_concurrent(\n            exchange=clear_exchange(self.exchange_view.accelerator, clear_tools=True),\n            file_list=files,\n            project_name=project_directory.split(\"/\")[-1],\n        )\n\n        return summary\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext.is_mono_repo","title":"<code>is_mono_repo: bool</code>  <code>property</code>","text":"<p>An boolean indicator of whether the local repository is part of a monorepo</p> <p>Returns:</p> Name Type Description <code>boolean</code> <code>bool</code> <p>True if above 2000 MB; False otherwise</p>"},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext.repo_size","title":"<code>repo_size: float</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the size of the repo in MB (if Goose detects its running in a local repository</p> <p>This measurement can be used to guess if the local repository is a monorepo</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>size of project in MB</p>"},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext.determine_git_proj","title":"<code>determine_git_proj()</code>","text":"<p>Determines the root as well as where Goose is currently running</p> <p>If the project is not part of a Github repo, the root of the project will be defined as the current working directory</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>path to the root of the project (if part of a local repository) or the CWD if not</p> <code>boolean</code> <code>bool</code> <p>if Goose is operating within local repository or not</p> <code>str</code> <code>str</code> <p>path to where the Goose session is running (the CWD)</p> Source code in <code>src/goose/toolkit/repo_context/repo_context.py</code> <pre><code>def determine_git_proj(self) -&gt; tuple[str, bool, str]:\n    \"\"\"Determines the root as well as where Goose is currently running\n\n    If the project is not part of a Github repo, the root of the project will be defined as the current working\n    directory\n\n    Returns:\n        str: path to the root of the project (if part of a local repository) or the CWD if not\n        boolean: if Goose is operating within local repository or not\n        str: path to where the Goose session is running (the CWD)\n    \"\"\"\n    # FIXME: monorepos\n    cwd = os.getcwd()\n    command = \"git rev-parse --show-toplevel\"\n    result: CompletedProcess = run(command, shell=True, text=True, capture_output=True, check=False)\n    if result.returncode == 0:\n        project_root = result.stdout.strip()\n        return project_root, True, cwd\n    else:\n        self.notifier.log(\"Not part of a Git repository. Returning current working directory\")\n        return cwd, False, cwd\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/repo_context.html#goose.toolkit.repo_context.repo_context.RepoContext.summarize_current_project","title":"<code>summarize_current_project()</code>","text":"<p>Summarizes the current project based on repo root (if git repo) or current project_directory (if not)</p> <p>Returns:</p> Name Type Description <code>summary</code> <code>dict[str, str]</code> <p>Keys are file paths and values are the summaries</p> Source code in <code>src/goose/toolkit/repo_context/repo_context.py</code> <pre><code>@tool\ndef summarize_current_project(self) -&gt; dict[str, str]:\n    \"\"\"Summarizes the current project based on repo root (if git repo) or current project_directory (if not)\n\n    Returns:\n        summary (dict[str, str]): Keys are file paths and values are the summaries\n    \"\"\"\n\n    self.notifier.log(\"Summarizing the most relevant files in the current project. This may take a while...\")\n\n    if self.is_mono_repo:\n        self.notifier.log(\"This might be a monorepo. Goose performs better on smaller projects. Using CWD.\")\n        # TODO: prompt user to specify a subdirectory\n        project_directory = self.goose_session_root\n    else:\n        project_directory = self.repo_project_root\n\n    # before selecting files and summarizing look for summarization file\n    project_name = project_directory.split(\"/\")[-1]\n    summary = load_summary_file_if_exists(project_name=project_name)\n    if summary:\n        self.notifier.log(\"Summary file for project exists already -- loading into the context\")\n        return summary\n\n    # clear exchange and replace the system prompt with instructions on why and how to select files to summarize\n    file_select_exchange = clear_exchange(self.exchange_view.accelerator, clear_tools=True)\n    system = Message.load(\"prompts/repo_context.jinja\").text\n    file_select_exchange = replace_prompt(exchange=file_select_exchange, prompt=system)\n    files = goose_picks_files(root=project_directory, exchange=file_select_exchange)\n\n    # summarize the selected files using a blank exchange with no tools\n    summary = summarize_files_concurrent(\n        exchange=clear_exchange(self.exchange_view.accelerator, clear_tools=True),\n        file_list=files,\n        project_name=project_directory.split(\"/\")[-1],\n    )\n\n    return summary\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/utils.html","title":"Utils","text":""},{"location":"reference/goose/toolkit/repo_context/utils.html#goose.toolkit.repo_context.utils.get_files_and_directories","title":"<code>get_files_and_directories(root_dir)</code>","text":"<p>Gets file names and directory names. Checks that goose has correctly typed the file and directory names and that the files actually exist (to avoid downstream file read errors).</p> <p>Parameters:</p> Name Type Description Default <code>root_dir</code> <code>str</code> <p>Path to the directory to examine for files and sub-directories</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, list]</code> <p>A list of files and directories in the form {'files': [], 'directories: []}. Paths are all relative (i.e. ['src'] not ['goose/src'])</p> Source code in <code>src/goose/toolkit/repo_context/utils.py</code> <pre><code>def get_files_and_directories(root_dir: str) -&gt; dict[str, list]:\n    \"\"\"Gets file names and directory names. Checks that goose has correctly typed the file and directory names and that\n    the files actually exist (to avoid downstream file read errors).\n\n    Args:\n        root_dir (str): Path to the directory to examine for files and sub-directories\n\n    Returns:\n        dict: A list of files and directories in the form {'files': [], 'directories: []}. Paths\n            are all relative (i.e. ['src'] not ['goose/src'])\n    \"\"\"\n    files = []\n    dirs = []\n\n    # check dir exists\n    try:\n        os.listdir(root_dir)\n    except FileNotFoundError:\n        # FIXME: fuzzy match might work here to recover directories 'lost' to goose mistyping\n        # hallucination: Goose mistyped the path (e.g. `metrichandler` vs `metricshandler`)\n        return {\"files\": files, \"directories\": dirs}\n\n    for entry in os.listdir(root_dir):\n        if entry.startswith(\".\") or entry.startswith(\"~\"):\n            continue  # Skip hidden files and directories\n\n        full_path = os.path.join(root_dir, entry)\n        if os.path.isdir(full_path):\n            dirs.append(entry)\n        elif os.path.isfile(full_path):\n            files.append(entry)\n\n    return {\"files\": files, \"directories\": dirs}\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/utils.html#goose.toolkit.repo_context.utils.get_repo_size","title":"<code>get_repo_size(repo_path)</code>","text":"<p>Returns repo size in MB</p> Source code in <code>src/goose/toolkit/repo_context/utils.py</code> <pre><code>def get_repo_size(repo_path: str) -&gt; int:\n    \"\"\"Returns repo size in MB\"\"\"\n    git_dir = os.path.join(repo_path, \".git\")\n    return get_directory_size(git_dir) / (1024**2)\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/utils.html#goose.toolkit.repo_context.utils.goose_picks_files","title":"<code>goose_picks_files(root, exchange, max_workers=4)</code>","text":"<p>Lets goose pick files in a BFS manner</p> Source code in <code>src/goose/toolkit/repo_context/utils.py</code> <pre><code>def goose_picks_files(root: str, exchange: Exchange, max_workers: int = 4) -&gt; list[str]:\n    \"\"\"Lets goose pick files in a BFS manner\"\"\"\n    queue = deque([root])\n\n    all_files = []\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n        while queue:\n            current_batch = [queue.popleft() for _ in range(min(max_workers, len(queue)))]\n            futures = {executor.submit(process_directory, dir, exchange): dir for dir in current_batch}\n\n            for future in concurrent.futures.as_completed(futures):\n                files, next_dirs = future.result()\n                all_files.extend(files)\n                queue.extend(next_dirs)\n\n    return all_files\n</code></pre>"},{"location":"reference/goose/toolkit/repo_context/utils.html#goose.toolkit.repo_context.utils.process_directory","title":"<code>process_directory(current_dir, exchange)</code>","text":"<p>Allows goose to pick files and subdirectories contained in a given directory (current_dir). Get the list of file and directory names in the current folder, then ask Goose to pick which ones to keep.</p> Source code in <code>src/goose/toolkit/repo_context/utils.py</code> <pre><code>def process_directory(current_dir: str, exchange: Exchange) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Allows goose to pick files and subdirectories contained in a given directory (current_dir). Get the list of file\n    and directory names in the current folder, then ask Goose to pick which ones to keep.\n\n    \"\"\"\n    files_and_dirs = get_files_and_directories(current_dir)\n    ai_response = ask_an_ai(str(files_and_dirs), exchange)\n\n    # FIXME: goose response validation\n    try:\n        as_dict = ast.literal_eval(ai_response.text)\n    except Exception:\n        # can happen if goose returns anything but {result: dict} (e.g. ```json\\n {results: dict} \\n```)\n        return [], []\n    if not isinstance(as_dict, dict):\n        # can happen if goose returns something like `{'files': ['x.py'] 'directories': ['dir1']}` (missing comma)\n        return [], []\n\n    files = [f\"{current_dir}/{file}\" for file in as_dict.get(\"files\", [])]\n    next_dirs = [f\"{current_dir}/{next_dir}\" for next_dir in as_dict.get(\"directories\", [])]\n\n    return files, next_dirs\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/index.html","title":"Index","text":""},{"location":"reference/goose/toolkit/summarization/summarize_file.html","title":"Summarize file","text":""},{"location":"reference/goose/toolkit/summarization/summarize_file.html#goose.toolkit.summarization.summarize_file.SummarizeFile","title":"<code>SummarizeFile</code>","text":"<p>               Bases: <code>Toolkit</code></p> Source code in <code>src/goose/toolkit/summarization/summarize_file.py</code> <pre><code>class SummarizeFile(Toolkit):\n    @tool\n    def summarize_file(self, filepath: str, prompt: Optional[str] = None) -&gt; str:\n        \"\"\"\n        Tool to summarize a specific file\n\n        Args:\n            filepath (str): Path to the file to summarize\n            prompt (str): Optional prompt giving the model instructions on how to summarize the file.\n                Under the hood this defaults to \"Please summarize this file\"\n\n        Returns:\n            summary (Optional[str]): Summary of the file contents\n\n        \"\"\"\n\n        exchange = self.exchange_view.accelerator\n\n        _, summary = summarize_file(filepath=filepath, exchange=exchange, prompt=prompt)\n\n        return summary\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_file.html#goose.toolkit.summarization.summarize_file.SummarizeFile.summarize_file","title":"<code>summarize_file(filepath, prompt=None)</code>","text":"<p>Tool to summarize a specific file</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the file to summarize</p> required <code>prompt</code> <code>str</code> <p>Optional prompt giving the model instructions on how to summarize the file. Under the hood this defaults to \"Please summarize this file\"</p> <code>None</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>Optional[str]</code> <p>Summary of the file contents</p> Source code in <code>src/goose/toolkit/summarization/summarize_file.py</code> <pre><code>@tool\ndef summarize_file(self, filepath: str, prompt: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Tool to summarize a specific file\n\n    Args:\n        filepath (str): Path to the file to summarize\n        prompt (str): Optional prompt giving the model instructions on how to summarize the file.\n            Under the hood this defaults to \"Please summarize this file\"\n\n    Returns:\n        summary (Optional[str]): Summary of the file contents\n\n    \"\"\"\n\n    exchange = self.exchange_view.accelerator\n\n    _, summary = summarize_file(filepath=filepath, exchange=exchange, prompt=prompt)\n\n    return summary\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_project.html","title":"Summarize project","text":""},{"location":"reference/goose/toolkit/summarization/summarize_project.html#goose.toolkit.summarization.summarize_project.SummarizeProject","title":"<code>SummarizeProject</code>","text":"<p>               Bases: <code>Toolkit</code></p> Source code in <code>src/goose/toolkit/summarization/summarize_project.py</code> <pre><code>class SummarizeProject(Toolkit):\n    @tool\n    def get_project_summary(\n        self,\n        project_dir_path: Optional[str] = os.getcwd(),\n        extensions: Optional[list[str]] = None,\n        summary_instructions_prompt: Optional[str] = None,\n    ) -&gt; dict:\n        \"\"\"Generates or retrieves a project summary based on specified file extensions.\n\n        Args:\n            project_dir_path (Optional[Path]): Path to the project directory. Defaults to the current working directory\n                if None\n            extensions (Optional[list[str]]): Specific file extensions to summarize.\n            summary_instructions_prompt (Optional[str]): Instructions to give to the LLM about how to summarize each file. E.g.\n                \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"\n\n        Returns:\n            summary (dict): Project summary.\n        \"\"\"  # noqa: E501\n\n        summary = summarize_directory(\n            project_dir_path,\n            exchange=self.exchange_view.accelerator,\n            extensions=extensions,\n            summary_instructions_prompt=summary_instructions_prompt,\n        )\n\n        return summary\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_project.html#goose.toolkit.summarization.summarize_project.SummarizeProject.get_project_summary","title":"<code>get_project_summary(project_dir_path=os.getcwd(), extensions=None, summary_instructions_prompt=None)</code>","text":"<p>Generates or retrieves a project summary based on specified file extensions.</p> <p>Parameters:</p> Name Type Description Default <code>project_dir_path</code> <code>Optional[Path]</code> <p>Path to the project directory. Defaults to the current working directory if None</p> <code>getcwd()</code> <code>extensions</code> <code>Optional[list[str]]</code> <p>Specific file extensions to summarize.</p> <code>None</code> <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Instructions to give to the LLM about how to summarize each file. E.g. \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"</p> <code>None</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>dict</code> <p>Project summary.</p> Source code in <code>src/goose/toolkit/summarization/summarize_project.py</code> <pre><code>@tool\ndef get_project_summary(\n    self,\n    project_dir_path: Optional[str] = os.getcwd(),\n    extensions: Optional[list[str]] = None,\n    summary_instructions_prompt: Optional[str] = None,\n) -&gt; dict:\n    \"\"\"Generates or retrieves a project summary based on specified file extensions.\n\n    Args:\n        project_dir_path (Optional[Path]): Path to the project directory. Defaults to the current working directory\n            if None\n        extensions (Optional[list[str]]): Specific file extensions to summarize.\n        summary_instructions_prompt (Optional[str]): Instructions to give to the LLM about how to summarize each file. E.g.\n            \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"\n\n    Returns:\n        summary (dict): Project summary.\n    \"\"\"  # noqa: E501\n\n    summary = summarize_directory(\n        project_dir_path,\n        exchange=self.exchange_view.accelerator,\n        extensions=extensions,\n        summary_instructions_prompt=summary_instructions_prompt,\n    )\n\n    return summary\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_repo.html","title":"Summarize repo","text":""},{"location":"reference/goose/toolkit/summarization/summarize_repo.html#goose.toolkit.summarization.summarize_repo.SummarizeRepo","title":"<code>SummarizeRepo</code>","text":"<p>               Bases: <code>Toolkit</code></p> Source code in <code>src/goose/toolkit/summarization/summarize_repo.py</code> <pre><code>class SummarizeRepo(Toolkit):\n    @tool\n    def summarize_repo(\n        self,\n        repo_url: str,\n        specified_extensions: Optional[list[str]] = None,\n        summary_instructions_prompt: Optional[str] = None,\n    ) -&gt; dict:\n        \"\"\"\n        Retrieves a summary of a repository. Clones the repository if not already cloned and summarizes based on the\n        specified file extensions. If no extensions are specified, it summarizes the top `max_extensions` extensions.\n\n        Args:\n            repo_url (str): The URL of the repository to summarize.\n            specified_extensions (Optional[list[str]]): list of file extensions to summarize, e.g., [\"tf\", \"md\"]. If\n                this list is empty, then all files in the repo are summarized\n            summary_instructions_prompt (Optional[str]): Instructions to give to the LLM about how to summarize each file. E.g.\n                \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"\n\n        Returns:\n            summary (dict): A summary of the repository where keys are the file extensions and values are their\n                summaries.\n        \"\"\"  # noqa: E501\n\n        return summarize_repo(\n            repo_url=repo_url,\n            exchange=self.exchange_view.accelerator,\n            extensions=specified_extensions,\n            summary_instructions_prompt=summary_instructions_prompt,\n        )\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/summarize_repo.html#goose.toolkit.summarization.summarize_repo.SummarizeRepo.summarize_repo","title":"<code>summarize_repo(repo_url, specified_extensions=None, summary_instructions_prompt=None)</code>","text":"<p>Retrieves a summary of a repository. Clones the repository if not already cloned and summarizes based on the specified file extensions. If no extensions are specified, it summarizes the top <code>max_extensions</code> extensions.</p> <p>Parameters:</p> Name Type Description Default <code>repo_url</code> <code>str</code> <p>The URL of the repository to summarize.</p> required <code>specified_extensions</code> <code>Optional[list[str]]</code> <p>list of file extensions to summarize, e.g., [\"tf\", \"md\"]. If this list is empty, then all files in the repo are summarized</p> <code>None</code> <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Instructions to give to the LLM about how to summarize each file. E.g. \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"</p> <code>None</code> <p>Returns:</p> Name Type Description <code>summary</code> <code>dict</code> <p>A summary of the repository where keys are the file extensions and values are their summaries.</p> Source code in <code>src/goose/toolkit/summarization/summarize_repo.py</code> <pre><code>@tool\ndef summarize_repo(\n    self,\n    repo_url: str,\n    specified_extensions: Optional[list[str]] = None,\n    summary_instructions_prompt: Optional[str] = None,\n) -&gt; dict:\n    \"\"\"\n    Retrieves a summary of a repository. Clones the repository if not already cloned and summarizes based on the\n    specified file extensions. If no extensions are specified, it summarizes the top `max_extensions` extensions.\n\n    Args:\n        repo_url (str): The URL of the repository to summarize.\n        specified_extensions (Optional[list[str]]): list of file extensions to summarize, e.g., [\"tf\", \"md\"]. If\n            this list is empty, then all files in the repo are summarized\n        summary_instructions_prompt (Optional[str]): Instructions to give to the LLM about how to summarize each file. E.g.\n            \"Summarize the file in two sentences.\". The default instruction is \"Please summarize this file.\"\n\n    Returns:\n        summary (dict): A summary of the repository where keys are the file extensions and values are their\n            summaries.\n    \"\"\"  # noqa: E501\n\n    return summarize_repo(\n        repo_url=repo_url,\n        exchange=self.exchange_view.accelerator,\n        extensions=specified_extensions,\n        summary_instructions_prompt=summary_instructions_prompt,\n    )\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html","title":"Utils","text":""},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.load_summary_file_if_exists","title":"<code>load_summary_file_if_exists(project_name)</code>","text":"<p>Checks if a summary file exists at '.goose/summaries/projectname-summary.json. Returns contents of the file if it exists, otherwise returns None</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>name of the project or repo</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Optional[dict]: File contents, else None</p> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def load_summary_file_if_exists(project_name: str) -&gt; Optional[dict]:\n    \"\"\"Checks if a summary file exists at '.goose/summaries/projectname-summary.json. Returns contents of the file if\n    it exists, otherwise returns None\n\n    Args:\n        project_name (str): name of the project or repo\n\n    Returns:\n        Optional[dict]: File contents, else None\n    \"\"\"\n    summary_file_path = f\"{SUMMARIES_FOLDER}/{project_name}-summary.json\"\n    if Path(summary_file_path).exists():\n        with open(summary_file_path, \"r\") as f:\n            return json.load(f)\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.summarize_directory","title":"<code>summarize_directory(directory, exchange, extensions, summary_instructions_prompt=None)</code>","text":"<p>Summarize files in a given directory based on extensions. Will also recursively find files in subdirectories and summarize them.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>path to the top-level directory to summarize</p> required <code>exchange</code> <code>Exchange</code> <p>Exchange to use to summarize</p> required <code>extensions</code> <code>list[str]</code> <p>list of file-type extensions to summarize (and ignore all other extensions).</p> required <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Optional instructions to give to the exchange regarding summarization.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>file_summaries</code> <code>dict</code> <p>Keys are file names and values are summaries.</p> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def summarize_directory(\n    directory: str, exchange: Exchange, extensions: list[str], summary_instructions_prompt: Optional[str] = None\n) -&gt; dict[str, str]:\n    \"\"\"Summarize files in a given directory based on extensions. Will also recursively find files in subdirectories and\n    summarize them.\n\n    Args:\n        directory (str): path to the top-level directory to summarize\n        exchange (Exchange): Exchange to use to summarize\n        extensions (list[str]): list of file-type extensions to summarize (and ignore all other extensions).\n        summary_instructions_prompt (Optional[str]): Optional instructions to give to the exchange regarding summarization.\n\n    Returns:\n        file_summaries (dict): Keys are file names and values are summaries.\n\n    \"\"\"  # noqa: E501\n\n    # TODO: make sure that '.goose/summaries' is\n    # in the root of the current not relative to current dir or in cloned repo root\n    project_name = directory.split(\"/\")[-1]\n    summary_file = load_summary_file_if_exists(project_name)\n    if summary_file:\n        return summary_file\n\n    summary_file_path = f\"{SUMMARIES_FOLDER}/{project_name}-summary.json\"\n\n    # create the .goose/summaries folder if not already created\n    Path(SUMMARIES_FOLDER).mkdir(exist_ok=True, parents=True)\n\n    # select a subset of files to summarize based on file extension\n    files_to_summarize = create_file_list(directory, extensions=extensions)\n\n    file_summaries = summarize_files_concurrent(\n        exchange=exchange,\n        file_list=files_to_summarize,\n        project_name=project_name,\n        summary_instructions_prompt=summary_instructions_prompt,\n    )\n\n    summary_file_contents = {\"extensions\": extensions, \"summaries\": file_summaries}\n\n    # Write the summaries into a json\n    with open(summary_file_path, \"w\") as f:\n        json.dump(summary_file_contents, f, indent=2)\n\n    return file_summaries\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.summarize_file","title":"<code>summarize_file(filepath, exchange, prompt=None)</code>","text":"<p>Summarizes a single file</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the file to summarize.</p> required <code>exchange</code> <code>Exchange</code> <p>Exchange object to use for summarization.</p> required <code>prompt</code> <code>Optional[str]</code> <p>Defaults to \"Please summarize this file.\"</p> <code>None</code> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def summarize_file(filepath: str, exchange: Exchange, prompt: Optional[str] = None) -&gt; tuple[str, str]:\n    \"\"\"Summarizes a single file\n\n    Args:\n        filepath (str): Path to the file to summarize.\n        exchange (Exchange): Exchange object to use for summarization.\n        prompt (Optional[str]): Defaults to \"Please summarize this file.\"\n    \"\"\"\n    try:\n        with open(filepath, \"r\") as f:\n            file_text = f.read()\n    except Exception as e:\n        return filepath, f\"Error reading file {filepath}: {str(e)}\"\n\n    if not file_text:\n        return filepath, \"Empty file\"\n\n    try:\n        reply = ask_an_ai(\n            input=file_text, exchange=exchange, prompt=prompt if prompt else \"Please summarize this file.\"\n        )\n    except InitialMessageTooLargeError:\n        return filepath, \"File too large\"\n\n    return filepath, reply.text\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.summarize_files_concurrent","title":"<code>summarize_files_concurrent(exchange, file_list, project_name, summary_instructions_prompt=None)</code>","text":"<p>Takes in a list of files and summarizes them. Exchange does not keep history of the summarized files.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>Exchange</code> <p>Underlying exchange</p> required <code>file_list</code> <code>list[str]</code> <p>list of paths to files to summarize</p> required <code>project_name</code> <code>str</code> <p>Used to save the summary of the files to .goose/summaries/-summary.json required <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Summary instructions for the LLM. Defaults to \"Please summarize this file.\"</p> <code>None</code> <p>Returns:</p> Name Type Description <code>file_summaries</code> <code>dict[str, str]</code> <p>Keys are file paths and values are the summaries returned by the Exchange</p> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def summarize_files_concurrent(\n    exchange: Exchange, file_list: list[str], project_name: str, summary_instructions_prompt: Optional[str] = None\n) -&gt; dict[str, str]:\n    \"\"\"Takes in a list of files and summarizes them. Exchange does not keep history of the summarized files.\n\n    Args:\n        exchange (Exchange): Underlying exchange\n        file_list (list[str]): list of paths to files to summarize\n        project_name (str): Used to save the summary of the files to .goose/summaries/&lt;project_name&gt;-summary.json\n        summary_instructions_prompt (Optional[str]): Summary instructions for the LLM. Defaults to \"Please summarize\n            this file.\"\n\n    Returns:\n        file_summaries (dict[str, str]): Keys are file paths and values are the summaries returned by the Exchange\n    \"\"\"\n    summary_file = load_summary_file_if_exists(project_name)\n    if summary_file:\n        return summary_file\n\n    file_summaries = {}\n    # compile the individual file summaries into a single summary dict\n    # TODO: add progress bar as this step can take quite some time and it's nice to see something is happening\n    with ThreadPoolExecutor() as executor:\n        future_to_file = {\n            executor.submit(summarize_file, file, exchange, summary_instructions_prompt): file for file in file_list\n        }\n\n        for future in as_completed(future_to_file):\n            file_name, file_summary = future.result()\n            file_summaries[file_name] = file_summary\n\n    # create summaries folder if it doesn't exist\n    Path(SUMMARIES_FOLDER).mkdir(exist_ok=True, parents=True)\n    summary_file_path = f\"{SUMMARIES_FOLDER}/{project_name}-summary.json\"\n\n    # Write the summaries into a json\n    with open(summary_file_path, \"w\") as f:\n        json.dump(file_summaries, f, indent=2)\n\n    return file_summaries\n</code></pre>"},{"location":"reference/goose/toolkit/summarization/utils.html#goose.toolkit.summarization.utils.summarize_repo","title":"<code>summarize_repo(repo_url, exchange, extensions, summary_instructions_prompt=None)</code>","text":"<p>Clones (if needed) and summarizes a repo</p> <p>Parameters:</p> Name Type Description Default <code>repo_url</code> <code>str</code> <p>Repository url</p> required <code>exchange</code> <code>Exchange</code> <p>Exchange for summarizing the repo.</p> required <code>extensions</code> <code>list[str]</code> <p>list of file-types to summarize.</p> required <code>summary_instructions_prompt</code> <code>Optional[str]</code> <p>Optional parameter to customize summarization results. Defaults to \"Please summarize this file\"</p> <code>None</code> Source code in <code>src/goose/toolkit/summarization/utils.py</code> <pre><code>def summarize_repo(\n    repo_url: str,\n    exchange: Exchange,\n    extensions: list[str],\n    summary_instructions_prompt: Optional[str] = None,\n) -&gt; dict[str, str]:\n    \"\"\"Clones (if needed) and summarizes a repo\n\n    Args:\n        repo_url (str): Repository url\n        exchange (Exchange): Exchange for summarizing the repo.\n        extensions (list[str]): list of file-types to summarize.\n        summary_instructions_prompt (Optional[str]): Optional parameter to customize summarization results. Defaults to\n            \"Please summarize this file\"\n    \"\"\"\n    # set up the paths for the repository and the summary file\n    repo_name = repo_url.split(\"/\")[-1]\n    repo_dir = f\"{CLONED_REPOS_FOLDER}/{repo_name}\"  # e.g. '.goose/cloned_repos/&lt;project-name&gt;'\n\n    if Path(repo_dir).exists():\n        # TODO: re-add ability to log\n        return summarize_directory(\n            directory=repo_dir,\n            exchange=exchange,\n            extensions=extensions,\n            summary_instructions_prompt=summary_instructions_prompt,\n        )\n\n    clone_repo(repo_url, target_directory=repo_dir)\n\n    return summarize_directory(\n        directory=repo_dir,\n        exchange=exchange,\n        extensions=extensions,\n        summary_instructions_prompt=summary_instructions_prompt,\n    )\n</code></pre>"},{"location":"reference/goose/utils/index.html","title":"Index","text":""},{"location":"reference/goose/utils/index.html#goose.utils.ensure","title":"<code>ensure(cls)</code>","text":"<p>Convert dictionary to a class instance</p> Source code in <code>src/goose/utils/__init__.py</code> <pre><code>def ensure(cls: type[T]) -&gt; Callable[[any], T]:\n    \"\"\"Convert dictionary to a class instance\"\"\"\n\n    def converter(val: any) -&gt; T:  # noqa: ANN401\n        if isinstance(val, cls):\n            return val\n        elif isinstance(val, dict):\n            return cls(**val)\n        elif isinstance(val, list):\n            return cls(*val)\n        else:\n            return cls(val)\n\n    return converter\n</code></pre>"},{"location":"reference/goose/utils/index.html#goose.utils.ensure_list","title":"<code>ensure_list(cls)</code>","text":"<p>Convert a list of dictionaries to class instances</p> Source code in <code>src/goose/utils/__init__.py</code> <pre><code>def ensure_list(cls: type[T]) -&gt; Callable[[list[dict[str, any]]], type[T]]:\n    \"\"\"Convert a list of dictionaries to class instances\"\"\"\n\n    def converter(val: list[dict[str, any]]) -&gt; list[T]:\n        output = []\n        for entry in val:\n            output.append(ensure(cls)(entry))\n        return output\n\n    return converter\n</code></pre>"},{"location":"reference/goose/utils/index.html#goose.utils.load_plugins","title":"<code>load_plugins(group)</code>","text":"<p>Load plugins based on a specified entry point group.</p> <p>This function iterates through all entry points registered under a specified group</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>The entry point group to load plugins from. This should match the group specified          in the package setup where plugins are defined.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary where each key is the entry point name, and the value is the loaded plugin object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Propagates exceptions raised by entry point loading, which might occur if a plugin        is not found or if there are issues with the plugin's code.</p> Source code in <code>src/goose/utils/__init__.py</code> <pre><code>def load_plugins(group: str) -&gt; dict:\n    \"\"\"\n    Load plugins based on a specified entry point group.\n\n    This function iterates through all entry points registered under a specified group\n\n    Args:\n        group (str): The entry point group to load plugins from. This should match the group specified\n                     in the package setup where plugins are defined.\n\n    Returns:\n        dict: A dictionary where each key is the entry point name, and the value is the loaded plugin object.\n\n    Raises:\n        Exception: Propagates exceptions raised by entry point loading, which might occur if a plugin\n                   is not found or if there are issues with the plugin's code.\n    \"\"\"\n    plugins = {}\n    # Access all entry points for the specified group and load each.\n    for entrypoint in entry_points(group=group):\n        plugin = entrypoint.load()  # Load the plugin.\n        plugins[entrypoint.name] = plugin  # Store the loaded plugin in the dictionary.\n    return plugins\n</code></pre>"},{"location":"reference/goose/utils/ask.html","title":"Ask","text":""},{"location":"reference/goose/utils/ask.html#goose.utils.ask.ask_an_ai","title":"<code>ask_an_ai(input, exchange, prompt='', no_history=True, with_tools=True)</code>","text":"<p>Sends a separate message to an LLM using a separate Exchange than the one underlying the Goose session.</p> <p>Can be used to summarize a file, or submit any other request that you'd like to an AI. The Exchange can have a history/prior context, or be wiped clean (by setting no_history to True).</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str</code> <p>The user's input string to be processed by the AI. Must be a non-empty string. Example: text from a file.</p> required <code>exchange</code> <code>Exchange</code> <p>An object representing the AI exchange system which manages the state and flow of the conversation.</p> required <code>prompt</code> <code>str</code> <p>An optional new prompt to replace the current one in the exchange system. Defaults to None. Example: \"Please summarize this file.\"</p> <code>''</code> <code>no_history</code> <code>bool</code> <p>A flag to determine if the conversation history should be cleared before processing the new input. True clears the context, False retains it. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>reply</code> <code>str</code> <p>The AI's reply as a string.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the <code>input</code> is not a non-empty string.</p> <code>Exception</code> <p>If there is an issue within the exchange system, including errors from the provider or model.</p> Example Source code in <code>src/goose/utils/ask.py</code> <pre><code>def ask_an_ai(\n    input: str,\n    exchange: Exchange,\n    prompt: str = \"\",\n    no_history: bool = True,\n    with_tools: bool = True,\n) -&gt; Message:\n    \"\"\"Sends a separate message to an LLM using a separate Exchange than the one underlying the Goose session.\n\n    Can be used to summarize a file, or submit any other request that you'd like to an AI. The Exchange can have a\n    history/prior context, or be wiped clean (by setting no_history to True).\n\n    Parameters:\n        input (str): The user's input string to be processed by the AI. Must be a non-empty string. Example: text from\n            a file.\n        exchange (Exchange): An object representing the AI exchange system which manages the state and flow of the\n            conversation.\n        prompt (str, optional): An optional new prompt to replace the current one in the exchange system. Defaults to\n            None. Example: \"Please summarize this file.\"\n        no_history (bool, optional): A flag to determine if the conversation history should be cleared before\n            processing the new input. True clears the context, False retains it. Defaults to True.\n\n    Returns:\n        reply (str): The AI's reply as a string.\n\n    Raises:\n        TypeError: If the `input` is not a non-empty string.\n        Exception: If there is an issue within the exchange system, including errors from the provider or model.\n\n    Example:\n        # Create an instance of an Exchange system\n        exchange_system = Exchange(provider=OpenAIProvider.from_env(), model=\"gpt-4\")\n\n        # Simulate asking the AI a question\n        response = ask_an_ai(\"What is the weather today?\", exchange_system)\n\n        print(response)  # Outputs the AI's response to the question.\n    \"\"\"\n    if no_history:\n        exchange = clear_exchange(exchange)\n\n    if not with_tools:\n        exchange = exchange.replace(tools=())\n\n    if prompt:\n        exchange = replace_prompt(exchange, prompt)\n\n    if not input:\n        raise TypeError(\"`input` must be a string of finite length\")\n\n    msg = Message.user(input)\n    exchange.add(msg)\n    reply = exchange.reply()\n\n    return reply\n</code></pre>"},{"location":"reference/goose/utils/ask.html#goose.utils.ask.ask_an_ai--create-an-instance-of-an-exchange-system","title":"Create an instance of an Exchange system","text":"<p>exchange_system = Exchange(provider=OpenAIProvider.from_env(), model=\"gpt-4\")</p>"},{"location":"reference/goose/utils/ask.html#goose.utils.ask.ask_an_ai--simulate-asking-the-ai-a-question","title":"Simulate asking the AI a question","text":"<p>response = ask_an_ai(\"What is the weather today?\", exchange_system)</p> <p>print(response)  # Outputs the AI's response to the question.</p>"},{"location":"reference/goose/utils/ask.html#goose.utils.ask.clear_exchange","title":"<code>clear_exchange(exchange, clear_tools=False)</code>","text":"<p>Clears the exchange object</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>Exchange</code> <p>Exchange object to be overwritten. Messages and checkpoints are replaced with empty lists.</p> required <code>clear_tools</code> <code>bool</code> <p>Boolean to indicate whether tools should be dropped from the exchange.</p> <code>False</code> <p>Returns:</p> Type Description <code>Exchange</code> <p>new_exchange (Exchange)</p> Source code in <code>src/goose/utils/ask.py</code> <pre><code>def clear_exchange(exchange: Exchange, clear_tools: bool = False) -&gt; Exchange:\n    \"\"\"Clears the exchange object\n\n    Args:\n        exchange (Exchange): Exchange object to be overwritten. Messages and checkpoints are replaced with empty lists.\n        clear_tools (bool): Boolean to indicate whether tools should be dropped from the exchange.\n\n    Returns:\n        new_exchange (Exchange)\n\n    \"\"\"\n    if clear_tools:\n        new_exchange = exchange.replace(messages=[], checkpoint_data=CheckpointData(), tools=())\n    else:\n        new_exchange = exchange.replace(messages=[], checkpoint_data=CheckpointData())\n    return new_exchange\n</code></pre>"},{"location":"reference/goose/utils/ask.html#goose.utils.ask.replace_prompt","title":"<code>replace_prompt(exchange, prompt)</code>","text":"<p>Replaces the system prompt</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>Exchange</code> <p>Exchange object to be overwritten. Messages and checkpoints are replaced with empty lists.</p> required <code>prompt</code> <code>str</code> <p>The system prompt.</p> required <p>Returns:</p> Type Description <code>Exchange</code> <p>new_exchange (Exchange)</p> Source code in <code>src/goose/utils/ask.py</code> <pre><code>def replace_prompt(exchange: Exchange, prompt: str) -&gt; Exchange:\n    \"\"\"Replaces the system prompt\n\n    Args:\n        exchange (Exchange): Exchange object to be overwritten. Messages and checkpoints are replaced with empty lists.\n        prompt (str): The system prompt.\n\n    Returns:\n        new_exchange (Exchange)\n    \"\"\"\n\n    new_exchange = exchange.replace(system=prompt)\n    return new_exchange\n</code></pre>"},{"location":"reference/goose/utils/file_utils.html","title":"File utils","text":""},{"location":"reference/goose/utils/file_utils.html#goose.utils.file_utils.create_extensions_list","title":"<code>create_extensions_list(project_root, max_n)</code>","text":"<p>Get the top N file extensions in the current project Args:     project_root (str): Root of the project to analyze     max_n (int): The number of file extensions to return Returns:     extensions (list[str]): A list of the top N file extensions</p> Source code in <code>src/goose/utils/file_utils.py</code> <pre><code>def create_extensions_list(project_root: str, max_n: int) -&gt; list:\n    \"\"\"Get the top N file extensions in the current project\n    Args:\n        project_root (str): Root of the project to analyze\n        max_n (int): The number of file extensions to return\n    Returns:\n        extensions (list[str]): A list of the top N file extensions\n    \"\"\"\n    if max_n == 0:\n        raise (ValueError(\"Number of file extensions must be greater than 0\"))\n\n    files = create_file_list(project_root, [])\n\n    counter = Counter()\n\n    for file in files:\n        file_path = Path(file)\n        if file_path.suffix:  # omit ''\n            counter[file_path.suffix] += 1\n\n    top_n = counter.most_common(max_n)\n    extensions = [ext for ext, _ in top_n]\n\n    return extensions\n</code></pre>"},{"location":"reference/goose/utils/file_utils.html#goose.utils.file_utils.create_file_list","title":"<code>create_file_list(dir_path, extensions)</code>","text":"<p>Creates a list of files with certain extensions</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>str</code> <p>Directory to list files of. Will include files recursively in sub-directories.</p> required <code>extensions</code> <code>list[str]</code> <p>list of file extensions to select for. If empty list, return all files</p> required <p>Returns:</p> Name Type Description <code>final_file_list</code> <code>list[str]</code> <p>list of file paths with specified extensions.</p> Source code in <code>src/goose/utils/file_utils.py</code> <pre><code>def create_file_list(dir_path: str, extensions: list[str]) -&gt; list[str]:\n    \"\"\"Creates a list of files with certain extensions\n\n    Args:\n        dir_path (str): Directory to list files of. Will include files recursively in sub-directories.\n        extensions (list[str]): list of file extensions to select for. If empty list, return all files\n\n    Returns:\n        final_file_list (list[str]): list of file paths with specified extensions.\n    \"\"\"\n    # if extensions is empty list, return all files\n    if not extensions:\n        return glob.glob(f\"{dir_path}/**/*\", recursive=True)\n\n    # prune out files that do not end with any of the extensions in extensions\n    final_file_list = []\n    for ext in extensions:\n        if ext and not ext.startswith(\".\"):\n            ext = f\".{ext}\"\n\n        files = glob.glob(f\"{dir_path}/**/*{ext}\", recursive=True)\n        final_file_list += files\n\n    return final_file_list\n</code></pre>"},{"location":"reference/goose/utils/file_utils.html#goose.utils.file_utils.create_language_weighting","title":"<code>create_language_weighting(files_in_directory)</code>","text":"<p>Calculate language weighting by file size to match GitHub's methodology.</p> <p>Parameters:</p> Name Type Description Default <code>files_in_directory</code> <code>list[str]</code> <p>Paths to files in the project directory</p> required <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>dict[str, float]: A dictionary with languages as keys and their percentage of the total codebase as values</p> Source code in <code>src/goose/utils/file_utils.py</code> <pre><code>def create_language_weighting(files_in_directory: list[str]) -&gt; dict[str, float]:\n    \"\"\"Calculate language weighting by file size to match GitHub's methodology.\n\n    Args:\n        files_in_directory (list[str]): Paths to files in the project directory\n\n    Returns:\n        dict[str, float]: A dictionary with languages as keys and their percentage of the total codebase as values\n    \"\"\"\n\n    # Initialize counters for sizes\n    size_by_language = Counter()\n\n    # Calculate size for files by language\n    for file_path in files_in_directory:\n        path = Path(file_path)\n        if path.suffix:\n            size_by_language[path.suffix] += os.path.getsize(file_path)\n\n    # Calculate total size and language percentages\n    total_size = sum(size_by_language.values())\n    language_percentages = {\n        lang: (size / total_size * 100) if total_size else 0 for lang, size in size_by_language.items()\n    }\n\n    return dict(sorted(language_percentages.items(), key=lambda item: item[1], reverse=True))\n</code></pre>"},{"location":"reference/goose/utils/file_utils.html#goose.utils.file_utils.list_files_with_extension","title":"<code>list_files_with_extension(dir_path, extension='')</code>","text":"<p>List all files in a directory with a given extension. Set extension to '' to return all files.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>str</code> <p>The path to the directory</p> required <code>extension</code> <code>Optional[str]</code> <p>extension to lookup. Defaults to '' which will return all files.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>files</code> <code>list[str]</code> <p>list of file paths</p> Source code in <code>src/goose/utils/file_utils.py</code> <pre><code>def list_files_with_extension(dir_path: str, extension: Optional[str] = \"\") -&gt; list[str]:\n    \"\"\"List all files in a directory with a given extension. Set extension to '' to return all files.\n\n    Args:\n        dir_path (str): The path to the directory\n        extension (Optional[str]): extension to lookup. Defaults to '' which will return all files.\n\n    Returns:\n        files (list[str]): list of file paths\n    \"\"\"\n    # add a leading '.' to extension if needed\n    if extension and not extension.startswith(\".\"):\n        extension = f\".{extension}\"\n\n    files = glob.glob(f\"{dir_path}/**/*{extension}\", recursive=True)\n    return files\n</code></pre>"},{"location":"reference/goose/utils/session_file.html","title":"Session file","text":""},{"location":"reference/goose/utils/shell/is_dangerous_command.html","title":"Is dangerous command","text":"<p>Check if the command matches any dangerous patterns.</p> <p>Dangerous patterns in this function are defined as commands that may present risk to system stability.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The shell command to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the command is dangerous, False otherwise.</p> Source code in <code>src/goose/utils/shell.py</code> <pre><code>def is_dangerous_command(command: str) -&gt; bool:\n    \"\"\"\n    Check if the command matches any dangerous patterns.\n\n    Dangerous patterns in this function are defined as commands that may present risk to system stability.\n\n    Args:\n        command (str): The shell command to check.\n\n    Returns:\n        bool: True if the command is dangerous, False otherwise.\n    \"\"\"\n    dangerous_patterns = [\n        # Commands that are generally unsafe\n        r\"\\brm\\b\",  # rm command\n        r\"\\bgit\\s+push\\b\",  # git push command\n        r\"\\bsudo\\b\",  # sudo command\n        r\"\\bmv\\b\",  # mv command\n        r\"\\bchmod\\b\",  # chmod command\n        r\"\\bchown\\b\",  # chown command\n        r\"\\bmkfs\\b\",  # mkfs command\n        r\"\\bsystemctl\\b\",  # systemctl command\n        r\"\\breboot\\b\",  # reboot command\n        r\"\\bshutdown\\b\",  # shutdown command\n        # Commands that kill processes\n        r\"\\b(kill|pkill|killall|xkill|skill)\\b\",\n        r\"\\bfuser\\b\\s*-[kK]\",  # fuser -k command\n        # Target files that are unsafe\n        r\"\\b~\\/\\.|\\/\\.\\w+\",  # commands that point to files or dirs in home that start with a dot (dotfiles)\n    ]\n    for pattern in dangerous_patterns:\n        if re.search(pattern, command):\n            return True\n    return False\n</code></pre>"},{"location":"blog/archive/2024.html","title":"2024","text":""},{"location":"blog/category/web-development.html","title":"Web Development","text":""}]}